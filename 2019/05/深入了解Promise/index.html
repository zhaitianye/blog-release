<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="翟天野 天野 翟天野博客 tianye zhaitianye" />
   
  <meta name="description" content="The seeker of the world" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    深入了解Promise |  Tianye Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/comm/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="/comm/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-深入了解Promise"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  深入了解Promise
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2019/05/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Promise/" class="article-date">
  <time datetime="2019-05-28T13:43:17.000Z" itemprop="datePublished">2019-05-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">30 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p>在异步编程中，Promise扮演了举足轻重的角色，它解决了ajax请求过程中的回调地狱的问题，令代码更具可读性。下面的介绍中，笔者会通过一些片段代码，加上一些其自己的理解带大家一起重新温故一下Promise为编程所带来的便利。 Promise是抽象异步处理对象以及对其进行各种操作的组件； 实例（假如此处你还不是很了解，没关系，先留个印象）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123; resolve(<span class="number">100</span>) &#125;;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>) &#123; reject(<span class="string">'error'</span>) &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">//100</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数 刚刚我们说，Promise解决了ajax请求过程中的回调地狱的问题，那么回调（函数）是什么，为什么要用到回调（函数），我们一起回顾一下。 回调函数（callback function），也被称作高阶函数。 就是把一个函数B作为参数（注意：是作为参数）传入“另一个函数A”中，然后这个函数B在“另一个函数A”中调用，那么这个函数B，就叫回调函数。函数A执行完以后执行函数B，这个过程就叫做回调。 注意：回调函数不是立即就执行。它是在另一个函数执行完成之后被调用，即在包含的函数体中指定的地方“回头调用”。 也就是：A（主函数）让 B（参数）做事，B做着做着，信息不够，不知道怎么做了，就需要A告诉他，这时，A到外面获取信息，待A执行完毕后拿到了所需信息，再回过头来调用B。</p>
<p>网上也有一个通俗易懂的例子帮助理解回调函数：</p>
<p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。 回调函数的使用场景：主要是需要将父函数的执行结果通知给回调函数进行处理时使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数举例1</span></span><br><span class="line">$(<span class="string">"#btn"</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">alert(<span class="string">"我是回调函数里的内容，点击后才出现，并没有立即执行"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数举例2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsyncMain</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">callback();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我是主函数'</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsyncCallback</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我是回调函数'</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>); <span class="comment">//此处模拟延迟加载</span></span><br><span class="line">&#125;</span><br><span class="line">runAsyncMain(runAsyncCallback); <span class="comment">//（先输出）我是主函数 (2s后输出) 我是回调函数</span></span><br></pre></td></tr></table></figure>

<p>可见此处主函数runAsyncMain执行的过程中，按顺序本应先执行回调函数，但输出结果却是后输出的回调函数内容，这说明，主函数不用等回调函数执行完再执行后续的语句，可以接着执行自己的代码，等回调函数准备好，再执行回调函数。所谓的异步加载也不过如此，当然，异步与回调并没有直接的联系，回调只是异步的一种实现方式。 为什么需要Promise? 介绍完回调函数，要回到Promise的主场了。程序执行过程中，有非常多的应用场景我们不能立即知道应该如何继续往下执行，例如很重要的<code>ajax请求</code>。通俗来说，由于网速的不同，可能你得到返回值的时间也不同，这时我们就需要等某个结果出来了之后才知道怎么样继续下去，例如下方的回调函数案例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：当一个ajax结束后，得到的值，需要作为另外一个ajax的参数被使用（即该参数得从上一个ajax请求中获取）</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'XXXXXX'</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XHR = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">XHR.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>); <span class="comment">//第一个ajax请求</span></span><br><span class="line">XHR.send();</span><br><span class="line"></span><br><span class="line">XHR.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (XHR.readyState == <span class="number">4</span> &amp;&amp; XHR.status == <span class="number">200</span>) &#123;</span><br><span class="line">result = XHR.response;</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="keyword">var</span> url2 = <span class="string">'XXXXXX'</span> + result.someParams; <span class="comment">//通过第一个ajax请求的结果，得到第二个ajax请求所需要的url</span></span><br><span class="line"><span class="keyword">var</span> XHR2 = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">XHR2.open(<span class="string">'GET'</span>, url2, <span class="literal">true</span>); <span class="comment">//第二个ajax请求</span></span><br><span class="line">XHR2.send();</span><br><span class="line">XHR2.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">... </span><br><span class="line"><span class="comment">//往复上述过程，会得到第三个ajax请求所需要的url值，然后进行第三个ajax请求，在得到第四个…… 超恐怖</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当上述需求中出现第三个ajax（甚至更多）仍然依赖上一个请求的时候，代码就会变成一场灾难。也就是我们常说的<code>回调地狱</code>。</p>
<p>这时，我们可能会希望：</p>
<ol>
<li>让代码变得更具有可读性和可维护性，减轻一层层套用数据和请求的现象；</li>
<li>将请求和数据处理明确的区分开。</li>
</ol>
<p>这时<code>Promise</code>就要闪亮登场了，Promise中强大的then方法，可以解决刚刚出现的恐怖的<code>回调地狱</code>问题，并且让代码更优雅。 别急，我们先从文档中最基础的 API 入手。</p>
<p>Promise的API 1、constructor （构造函数属性） <code>Promise</code>本身也是一个<code>构造函数</code>，需要通过这个构造函数创建一个新的<code>Promise</code>对象作为接口，使用<code>new</code>来调用<code>Promise</code>的构造器来进行实例化，所以这个实例化出来的新对象：具有constructor属性，并且指针指向他的构造函数Promise。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 此处代码会立即执行</span></span><br><span class="line"><span class="comment">// 当调用栈内容处理结束后，再通过promise.then()方法调用resolve 或 reject返回的数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>2、Instance Method （实例方法） promise.then() Promise对象中的<code>promise.then(resolve，reject)</code>实例方法，可以接收构造函数中处理的状态变化，通过此方法，设置了其值在resolve(成功)/reject(失败)时调用的回调函数，并分别对应执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>
<p>then方法有2个参数（都是可选参数，此参数是个回调函数）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* resolve成功时<span class="string">`onFulfilled`</span>会被调用；</span><br><span class="line">* reject失败时<span class="string">`onRejected`</span>会被调用。</span><br></pre></td></tr></table></figure>
<p><code>promise.then</code>成功和失败时都可以使用，并且<code>then方法的执行结果也会返回一个Promise对象</code>。</p>
<p>promise.catch() 另外在只想对异常进行处理时可以采用<code>promise.then(undefined, onRejected)</code>这种方式，只指定reject时的回调函数即可。不过这种情况下 <code>promise.catch(onRejected)</code>应该是个更好的选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.catch(onRejected)</span><br></pre></td></tr></table></figure>
<p>注意：在IE8及以下版本，使用<code>promise.catch()</code>的代码，会出现identifier not found的语法错误。（因为<code>catch</code>与ECMAScript的保留字[2](Reserved Word)有关，在ECMAScript 3中保留字是不能作为对象的属性名使用的。） 解决办法：不单纯的使用<code>catch</code>，而是使用<code>then</code>来避免这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//then和catch方法 举例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(value) == <span class="string">'number'</span>)&#123;</span><br><span class="line">resolve(<span class="string">"我是数字"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">reject(<span class="string">"我不是数字"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1：同时使用then和catch方法</span></span><br><span class="line"></span><br><span class="line">asyncFunction(<span class="number">123</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123; </span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：我是数字</span></span><br><span class="line"><span class="comment">//解说：执行过程 </span></span><br><span class="line"><span class="comment">// 1、在asyncFunction这个方法中创建一个Promise构造函数p，只要执行asyncFunction()就会返回一个Promise对象；</span></span><br><span class="line"><span class="comment">// 2、asyncFunction方法表示：如果传入的参数value值是数字，就输出"我是数字"，如果不是数字，就输出"我不是数字"</span></span><br><span class="line"><span class="comment">// 3、写法1中，为promise对象用设置 .then 方法调用返回值时的回调函数，.catch 方法来设置发生错误时的回调函数</span></span><br><span class="line"><span class="comment">// 4、promise对象会先判断resolve，并执行then方法，如果resolve执行通过，则不会执行catch方法，若上面代码在执行中产生异常，在 catch 中设置的回调函数就会被执行，并输出error。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2：只使用 then方法，不使用catch 方法</span></span><br><span class="line">asyncFunction(<span class="string">'abc'</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line"><span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;,(error) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//执行结果：我不是数字</span></span><br></pre></td></tr></table></figure>
<p>3、Static Method （静态方法） 像<code>Promise</code>这样的全局对象还拥有一些静态方法，后文中会有详细解释。 Promise.resolve() Promise.resolve()方法返回一个已给定值解析后的新的Promise对象，从而能继续使用then的链式方法调用。 Promise.reject() Promise.reject()方法和Promise.resolve()方法一样。 Promise.all() Promise.all()方法的作用是将多个<code>Promise</code>对象实例包装，生成并返回一个新的<code>Promise</code>实例。 Promise.race() Promise.race()与Promise.all()相反。 Promise的状态 (Fulfilled、Rejected、Pending) <code>Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用。</code> 用<code>new Promise</code>实例化的promise对象有以下三个状态：</p>
<ul>
<li>“unresolved” - <code>Pending</code>| 既不是resolve也不是reject的状态。等待中，或者进行中，表示Promise刚创建，还没有得到结果时的状态；</li>
<li>“has-resolution” - <code>Fulfilled</code>| resolve(成功)时。此时会调用<code>onFulfilled</code>；</li>
<li>“has-rejection” - <code>Rejected</code>| reject(失败)时。此时会调用<code>onRejected</code>。</li>
</ul>
<p>关于下面这三种状态的读法，其中左侧为在ES6 Promises规范中定义的术语，而右侧则是在Promises/A+中描述状态的术语。</p>
<p>意思是promise对象的状态，从_Pending_转换为_Fulfilled_或_Rejected_之后， 这个promise对象的状态就不会再发生任何变化，会一直保持这个结果。 当promise的对象状态发生变化时，用<code>.then</code>来定义只会被调用一次的函数。</p>
<p>Promise的使用 1、创建Promise对象 前面很多次强调，Promise本身就是一个构造函数，所以可以通过new创建新的Promise对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">//做一些异步操作</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'执行完成'</span>);</span><br><span class="line">resolve(<span class="string">'我的数据'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"我先执行"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//先输出：我先执行</span></span><br><span class="line"><span class="comment">//1秒之后输出：执行完成</span></span><br></pre></td></tr></table></figure>
<p>我们执行了一个<code>异步操作</code>，也就是setTimeout，1秒后，输出“执行完成”，并且调用resolve方法。但是只是new了一个Promise对象，并没有调用它，我们传进去的函数就已经执行了。为了避免这个现象产生，所以我们用Promise的时候一般是包在一个函数中，需要的时候去运行这个函数。</p>
<p>如果你对执行的先后顺序还不理解，推荐阅读文章事件的循环机制(Event loop)前文中我们也曾多次提到异步加载，所以此概念应熟记于心。</p>
<p><code>异步任务</code>：指不进入主线程、而<code>进入&quot;任务队列&quot;（task queue）的任务</code>，只有等主线程任务执行完毕，“任务队列”开始通知主线程，请求执行任务，该任务才会进入主线程执行。 异步加载例如：你烧壶水要冲咖啡，可是水要10分钟才能烧开，此时，你转身去写了个小程序，等10分钟后水好了，才回来继续冲咖啡的活动，中间你去做了很多别的有意义的事情，也并没有耽误冲咖啡这项任务，这就是异步。 也可以理解为可以改变程序正常执行顺序的操作就可以看成是异步操作。例如setTimeout和setInterval函数。 <code>同步任务</code>：指在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务； 同步加载例如：你烧壶水要冲咖啡，可是水要10分钟才能烧开，此时，你就等啊等啊等，等了10分钟水好了，才继续冲咖啡的活动，中间的过程就是等待，啥都不干，这就是同步。 你会发现，异步加载的举例和上文中强调的回调函数例子很像，但刚刚也强调了，异步与回调并没有直接的联系，回调只是异步的一种实现方式（再次重复，加深理解）。 你会不会以为异步像是多线程操作那样并列执行程序？我想说，千万不要这样想！js就是单线程，没有多线程一说，所以不存在并行，即便是异步，也是单线程，只不过是放在了异步队列里，对，是队列，倘若你不是很理解，那么请前去了解一下事件循环机制中的宏任务和微任务（promise就是微任务，settimeout是宏任务，非常不错的一篇文章）的区别，它们所在的队列是不同的，看过之后，相信你会对promise有更深刻的了解。 2、封装Promise对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">//创建一个Promise的新对象p</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> num == <span class="string">'number'</span>) &#123;</span><br><span class="line">resolve();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//这个（第一个）function是resolve对应的参数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这个是数字'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//这个（第二个）function是reject对应的参数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'我不是数字'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> p; <span class="comment">//此处返回对象p</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行这个函数我们得到了一个Promise构造出来的对象p，所以p.__proto__ === Promise.prototype，即p的指针指向了构造函数Promise，因此asyncFunction()能够使用Promise的属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此种写法可以多次调用asyncFunction这个方法</span></span><br><span class="line">asyncFunction(<span class="string">'hahha'</span>); <span class="comment">//我不是数字</span></span><br><span class="line">asyncFunction(<span class="number">1234</span>); <span class="comment">//这个是数字</span></span><br><span class="line"></span><br><span class="line">我们刚刚讲到，<span class="string">`then方法的执行结果也会返回一个Promise对象`</span>，得到一个结果。因此我们可以进行then的链式执行，接收上一个then返回回来的数据并继续执行，这也是<span class="string">`解决回调地狱`</span>的主要方式。 <span class="number">3</span>、<span class="built_in">Promise</span>的链式操作和数据传递 下面我们就来看看.then和.catch这两个方法返回的到底是不是新的promise对象。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);<span class="comment">// aPromise为原promise对象</span></span><br><span class="line"><span class="comment">// 下面分开进行.then和.catch操作</span></span><br><span class="line"><span class="keyword">var</span> thenPromise = aPromise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> catchPromise = thenPromise.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(aPromise !== thenPromise); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(aPromise !== catchPromise); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(thenPromise !== catchPromise);<span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p><code>===</code>是严格相等比较运算符，我们可以看出这三个对象都是互不相同的，这也就证明了<code>then</code>和<code>catch</code>都返回了和调用不同的promise对象。我们通过下面这个例子进一步来理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 对同一个promise对象同时调用 \`then\` 方法</span></span><br><span class="line"><span class="keyword">var</span> aPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">aPromise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1: "</span> + value); <span class="comment">// 1: 100</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// vs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: 对 \`then\` 进行 promise 链式 方式进行调用</span></span><br><span class="line"><span class="keyword">var</span> bPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">bPromise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"2: "</span> + value); <span class="comment">// 2: 400</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>写法1 中并没有使用promise的方法链方式，这在Promise中应该是极力避免的写法。这种写法中的<code>then</code>调用几乎是同时开始执行的，而且传给每个<code>then</code>方法的<code>value</code>值都是<code>100</code>。 写法2 则采用了方法链的方式将多个<code>then</code>方法调用串连在了一起，各函数也严格按照 resolve → then → then → then 的顺序执行，并且传给每个<code>then</code>方法的<code>value</code>的值都是前一个promise对象通过<code>return</code>返回的值，实现了Promise的数据传递。</p>
<p>强调：promise的链式操作实现了数据的传递，promise非链式操作的方法无法实现数据传递。</p>
<p>4、通过Promise封装ajax解决回调地狱问题</p>
<p>刚刚在开篇（【为什么需要Promise】 这一节），通过一个ajax的例子，引出了回调地狱的概念，强调了通过回调函数方式解决多级请求都依赖于上一级数据时所引发的问题。下面我们通过刚刚学习过的Promise内容（特别是.then的链式数据传递）对上面的ajax数据依赖的案例进行重写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; &#39;XXXXX&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 封装一个get请求的方法</span><br><span class="line">function getJSON(url) &#123;</span><br><span class="line">return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">var XHR &#x3D; new XMLHttpRequest();</span><br><span class="line">XHR.open(&#39;GET&#39;, url, true);</span><br><span class="line">XHR.send();</span><br><span class="line"></span><br><span class="line">XHR.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">if (XHR.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">if (XHR.status &#x3D;&#x3D; 200) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var response &#x3D; JSON.parse(XHR.responseText);</span><br><span class="line">resolve(response);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">reject(new Error(XHR.statusText));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getJSON(url)</span><br><span class="line">.then(resp &#x3D;&gt; &#123;</span><br><span class="line">console.log(response);</span><br><span class="line">return url2 &#x3D; &#39;http:xxx.yyy.com&#x2F;zzz?ddd&#x3D;&#39; + resp;</span><br><span class="line">&#125;)</span><br><span class="line">.then(resp &#x3D;&gt; &#123;</span><br><span class="line">console.log(response);</span><br><span class="line">return url3 &#x3D; &#39;http:xxx.yyy.com&#x2F;zzz?ddd&#x3D;&#39; + resp;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">new Promise写法的快捷方式 1、Promise.resolve</span><br><span class="line"></span><br><span class="line">new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">resolve(100);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">Promise.resolve(100); &#x2F;&#x2F;Promise.resolve(100); 可以认为是上述代码的语法糖。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用方法</span><br><span class="line">Promise.resolve(100).then(value &#x3D;&gt; &#123;</span><br><span class="line">console.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>另：<code>Promise.resolve</code>方法另一个作用就是将thenable对象转换为promise对象。</p>
<p>ES6 Promises提到了Thenable这个概念，简单来说它就是一个非常类似promise的东西。就像我们有时称具有<code>.length</code>方法的非数组对象为类数组（Array like）一样，thenable指的是一个具有<code>.then</code>方法的对象。 因为：类库没有提供<code>Promise</code>的实现，用户通过<code>Promise.resolve(thenable)</code>来自己实现了<code>Promise</code>，并且，作为Promise使用的时候，需要和<code>Promise.resolve(thenable)</code>一起配合使用，将thenable对象转换promise对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/json/comment.json'</span>));<span class="comment">// =&gt; promise对象</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在此不再对Thenable进行过多赘述，可自行了解。 2、Promise.reject</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错了"</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"出错了"</span>)); <span class="comment">// Promise.reject(new Error("出错了")) 就是上述代码的语法糖。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"BOOM!"</span>)).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise.all() <code>Promise.all</code>接收一个promise对象的<code>数组作为参数</code>，当这个数组里的所有promise对象全部变为resolve或reject状态的时候，它才会去调用<code>.then</code>方法。 也就是说：Promise的all方法提供了异步操作的能力，并且在所有异步操作执行完后才执行回调。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `delay`毫秒后执行resolve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerPromisefy</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">resolve(delay);</span><br><span class="line">&#125;, delay);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> startDate = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="comment">// 所有promise变为resolve后程序退出</span></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">timerPromisefy(<span class="number">1</span>),</span><br><span class="line">timerPromisefy(<span class="number">32</span>),</span><br><span class="line">timerPromisefy(<span class="number">64</span>),</span><br><span class="line">timerPromisefy(<span class="number">128</span>)</span><br><span class="line">]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - startDate + <span class="string">'ms'</span>);</span><br><span class="line"><span class="comment">// 约128ms</span></span><br><span class="line"><span class="built_in">console</span>.log(values); <span class="comment">// [1,32,64,128]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这说明<code>timerPromisefy</code>会每隔1、32、64、128ms都会有一个promise发生<code>resolve</code>行为，返回一个promise对象，状态为FulFilled，其状态值为传给<code>timerPromisefy</code>的参数，并且all会把所有异步操作的结果放进一个数组中传给then。</p>
<p>从上述结果可以看出，传递给<code>Promise.all</code>的promise并不是一个个的顺序执行的，而是<code>同时开始、并行执行</code>的。</p>
<p>Promise.race() all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，接收一个promise对象数组为参数。 <code>Promise.all</code>在接收到的所有的对象promise都变为FulFilled或者Rejected状态之后才会继续进行后面的处理，与之相对的是<code>Promise.race</code>只要有一个promise对象进入FulFilled或者Rejected状态的话，就会继续进行后面的处理。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `delay`毫秒后执行resolve</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerPromisefy</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">resolve(delay);</span><br><span class="line">&#125;, delay);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 任何一个promise变为resolve或reject 的话程序就停止运行</span></span><br><span class="line"><span class="built_in">Promise</span>.race(\[</span><br><span class="line">timerPromisefy(<span class="number">1</span>),</span><br><span class="line">timerPromisefy(<span class="number">32</span>),</span><br><span class="line">timerPromisefy(<span class="number">64</span>),</span><br><span class="line">timerPromisefy(<span class="number">128</span>)</span><br><span class="line">\]).then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// =&gt; 1</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码创建了4个promise对象，这些promise对象会分别在1ms、32ms、64ms和128ms后变为确定状态，即FulFilled，并且在第一个变为确定状态的1ms后，<code>.then</code>注册的回调函数就会被调用，这时候确定状态的promise对象会调用<code>resolve(1)</code>因此传递给<code>value</code>的值也是1，控制台上会打印出<code>1</code>来。</p>
<p>promise的基本使用原理以及它在实际应用中为我们解决的问题，在上述过程中已经介绍完了，你是否理解了呢？学习是一个反复阅读，反复加深印象的过程，加油牢牢掌握这一知识点，在vue、react等框架的使用中，也会频繁用到有关promise的知识，下面一起来检测一下对promise的认知结果吧。</p>
<p>小练习 下面内容的输出结果应该是啥？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"test2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"捕获错误: test1 or test2"</span>, error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">promise</span><br><span class="line">.then(test1)</span><br><span class="line">.then(test2)</span><br><span class="line">.catch(onRejected)</span><br><span class="line">.then(test3);</span><br></pre></td></tr></table></figure>
<p>提示：这里没有为<code>then</code>方法指定第二个参数(onRejected)。 补充1：对比 callback → Promise → async/await javascript的异步发展历程，从callback，到Promise对象、Generator函数，不停地优化程序上的编写方式，但又让人觉得不是很彻底，随即又有了之后的async/await的异步编程方式，让异步编程变得更像同步代码，增强了代码的可读性，甚至很多人评价async/await是异步操作的终极解决方案，接下来简单介绍一下这三种方式各自的优缺点： 1.callback（回调）：本文开篇也提及了回调函数虽然好理解，但只对于简单的异步程序，callback是可以胜任的，但是在ajax需要被多次调用时使用起来还是会产生很多问题：</p>
<ul>
<li>高耦合，让程序变得难以维护；</li>
<li>并且错误捕捉要通过人工的设置判断来进行。</li>
</ul>
<p>2.Promise：ES6提供的构造函数Promise的实现是要基于callback的，解决了异步执行的问题：</p>
<ul>
<li>通过Promise.then()链式调用的方法，解决了回调函数层层嵌套（回调地狱）的问题，让代码和操作都变得更加简洁；</li>
<li>可以统一通过Promise.catch()方法对异常进行捕获，无需再像callback那样，为每个异步操作添加异常处理；</li>
<li>Promise.all()方法可以对异步操作进行并行处理，同时执行多个操作。</li>
</ul>
<p>但Promise也存在缺点：</p>
<ul>
<li>当处于未完成状态时，无法确定目前处于哪一阶段；</li>
<li>如果不设置回调函数，Promise内部的错误不会反映到外部；</li>
<li>Promise一旦新建它就会立即执行，无法中途取消。</li>
</ul>
<p>ES6中，还有一个generator函数，以前一个函数中的代码要么被调用，要么不被调用，不存在能暂停的情况，generator函数让代码可以中途暂停、异步执行，它与Promise的结合使用，类似于async/await（见下文）效果的代码。 整个Generator函数就是一个封装的异步任务的容器。它的语法是在函数名前加个*号，在异步操作需要暂停的地方，都用yield语句注明，但仅有yield，函数是不会执行的，他需要调用next方法，指针都会向下移一个状态，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。</p>
<p>3.async/await：ES7中新增的异步编程方法，async/await的实现是基于 Promise的，简单而言就是async function就是返回Promise的function，是generator的语法糖，其实async函数就是将Generator函数的星号（*）替换成 async，将yield替换成await。很多人认为async/await是异步操作的终极解决方案：</p>
<ul>
<li>改进JS中异步操作串行执行的代码组织方式，减少callback的嵌套；</li>
<li>语法简洁，更像是同步代码，也更符合普通的阅读习惯；</li>
<li>Promise中不能自定义使用try/catch进行错误捕获，但是在Async/await中可以像处理同步代码处理错误。</li>
</ul>
<p>综上异步编程的演变过程可见，它语法目标，其实就是怎样让它更像同步编程。</p>
<p>补充2：Promise 的实现原理 一起回顾一下， 前面我们介绍了promise的来由、解决的问题、常用和重点的方法、以及promise的使用方法和应用场景，你是不是也很好奇，没有promise的话，我们要如何模拟出promise呢？也就是，promise是如何实现的？ 回顾一下Promise的使用过程： 1.首先要知道，Promise对象有三个状态：<code>Pending(进行中)</code>、<code>Fulfilled(已成功)</code>、<code>Rejected(已失败)</code>，所以需要Promise设置三个状态值； 2.Promise存在resolve和reject两个回调函数作为自身参数：new Promise((resolve, reject){});，通过判断步骤1中的三个状态值，来确定输出哪个方法，例如：</p>
<ul>
<li>promise处于Fulfilled状态时，就输出resolve对应的方法；</li>
<li>Rejected状态时就输出reject方法。</li>
</ul>
<p>3.Promise的then方法要接收两个参数：promise.then(onFulfilled, onRejected)，onFulfilled和onRejected也必须是两个函数：</p>
<ul>
<li>当Promise的状态为成功时，调用onFulfilled这个方法，其中onFulfilled方法中的参数是步骤2中promise成功状态 resolve执行时传入的值；</li>
<li>当Promise的状态为失败时，调用onRejected这个方法，其中onRejected方法中的参数是步骤2中promise失败状态reject执行时传入的值。</li>
</ul>
<p>4.如果then被同一个Promise多次调用，所有<code>onFulfilled</code>和<code>onRejected</code>需按照其注册顺序依次回调； 5.…… 6.当然，Promise还有.catch、.all、.race等很多方法，以及基本逻辑和规则确定后，还需要加上错误捕获、值传递等机制，例如判断步骤2中的回调函数是否为function、步骤4链式操作中，then返回的是否为一个新的Promise对象等等； 具体的Promise实现原理代码如下，若有兴趣的童鞋可参考阅读，帮助进一步加深理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">'function'</span></span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'FULFILLED'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(handle) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'MyPromise must accept a function as a parameter'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">undefined</span></span><br><span class="line">    <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._fulfilledQueues = \ [\]</span><br><span class="line">    <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._rejectedQueues = \ [\]</span><br><span class="line">    <span class="comment">// 执行handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="keyword">this</span>.\_resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.\_reject.bind(<span class="keyword">this</span>))</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">  _resolve(val) &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runFulfilled = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> (cb = <span class="keyword">this</span>._fulfilledQueues.shift()) &#123;</span><br><span class="line">          cb(value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runRejected = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> (cb = <span class="keyword">this</span>._rejectedQueues.shift()) &#123;</span><br><span class="line">          cb(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,</span></span><br><span class="line"><span class="comment">      当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        val.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>._value = value</span><br><span class="line">          <span class="keyword">this</span>._status = FULFILLED</span><br><span class="line">          runFulfilled(value)</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>._value = err</span><br><span class="line">          <span class="keyword">this</span>._status = REJECTED</span><br><span class="line">          runRejected(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = val</span><br><span class="line">        <span class="keyword">this</span>._status = FULFILLED</span><br><span class="line">        runFulfilled(val)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">  _reject(err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED</span><br><span class="line">      <span class="keyword">this</span>._value = err</span><br><span class="line">      <span class="keyword">let</span> cb;</span><br><span class="line">      <span class="keyword">while</span> (cb = <span class="keyword">this</span>._rejectedQueues.shift()) &#123;</span><br><span class="line">        cb(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加then方法</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;\ _value, \_status &#125; = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">            onFulfilledNext(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onFulfilled(value);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">            onRejectedNext(error)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(error);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._fulfilledQueues.push(fulfilled)</span><br><span class="line">          <span class="keyword">this</span>._rejectedQueues.push(rejected)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">          <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilled(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejected(_value)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加catch方法</span></span><br><span class="line">  <span class="keyword">catch</span> (onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果参数是MyPromise实例，直接返回这个实例</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态reject方法</span></span><br><span class="line">  <span class="keyword">static</span> reject(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态all方法</span></span><br><span class="line">  <span class="keyword">static</span> all(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      /\*\*\ * 返回值的集合</span><br><span class="line">        *</span><br><span class="line">        /</span><br><span class="line">      <span class="keyword">let</span> values = \ [\]</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span>\ [i, p\] <span class="keyword">of</span> list.entries()) &#123;</span><br><span class="line">        <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          values\[i\] = res</span><br><span class="line">          count++</span><br><span class="line">          <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">          <span class="keyword">if</span> (count === list.length) resolve(values)</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">          <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态race方法</span></span><br><span class="line">  <span class="keyword">static</span> race(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      value =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">      reason =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章，未经许可，任何单位及个人不得做营利性使用！如有侵权请联系作者。
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2019/05/ES2018%E6%96%B0%E7%89%B9%E6%80%A7/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            ES2018新特性
          
        </div>
      </a>
    
    
      <a href="/2019/05/2019%E5%B9%B4%E5%A4%A7%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%B6%8B%E5%8A%BF%E5%88%86%E6%9E%90/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">2019年大前端技术趋势分析</div>
      </a>
    
  </nav>

  
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 翟天野
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.svg" alt="Tianye Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  
  if(document.getElementsByClassName("tocbot").length !== 0){
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      scrollContainer: 'main',
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto'
    });
  }
</script>

<script src="/comm/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/comm/jquery.modal.min.css">
<script src="/comm/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="/comm/photoswipe_dist/photoswipe.css">
<link rel="stylesheet" href="/comm/photoswipe_dist/default-skin/default-skin.css">
<script src="/comm/photoswipe_dist/photoswipe.min.js"></script>
<script src="/comm/photoswipe_dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="/comm/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>