<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="翟天野 天野 翟天野博客 tianye zhaitianye" />
   
  <meta name="description" content="The seeker of the world" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    c++-编程模型 |  Tianye Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/comm/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="/comm/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-c++-编程模型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  c++-编程模型
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2015/12/c++-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time datetime="2015-12-29T10:22:05.000Z" itemprop="datePublished">2015-12-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/c/">c++</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">10.6k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">46 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p>1、 两种I/O模式 阻塞模式：执行I/O操作完成前会一直进行等待，不会将控制权交给程序。套接字 默认为阻塞模式。可以通过多线程技术进行处理。 非阻塞模式：执行I/O操作时，Winsock函数会返回并交出控制权。这种模式使用 起来比较复杂，因为函数在没有运行完成就进行返回，会不断地返回 WSAEWOULDBLOCK错误。但功能强大。 为了解决这个问题，提出了进行I/O操作的一些I/O模型,下面介绍最常见的三种： Windows Socket五种I/O模型——代码全攻略 如 果你想在Windows平台上构建服务器应用，那么I/O模型是你必须考虑的。Windows操作系统提供了选择（Select）、异步选择 （WSAAsyncSelect）、事件选择（WSAEventSelect）、重叠I/O（Overlapped I/O）和完成端口 （Completion Port)共五种I/O模型。每一种模型均适用于一种特定的应用场景。程序员应该对自己的应用需求非常明确，而且综合考虑到程序 的扩展性和可移植性等因素，作出自己的选择。 我会以一个回应反射式服务器（与《Windows网络编程》第八章一样）来介绍这五种I/O模型。 我们假设客户端的代码如下（为代码直观，省去所有错误检查，以下同）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WINSOCK2.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_ADDRESS <span class="meta-string">"137.117.2.148"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT           5150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE        1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WSADATA     wsaData;</span><br><span class="line">  SOCKET      sClient;</span><br><span class="line">  SOCKADDR_IN server;</span><br><span class="line">  <span class="keyword">char</span>        szMessage\[MSGSIZE\];</span><br><span class="line">  <span class="keyword">int</span>         ret;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Initialize Windows socket library</span></span><br><span class="line">  WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create client socket</span></span><br><span class="line">  sClient = socket(AF\_INET, SOCK\_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect to server</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;server, <span class="number">0</span>, <span class="keyword">sizeof</span>(SOCKADDR_IN));</span><br><span class="line">  server.<span class="built_in">sin</span>\_family = AF\_INET;</span><br><span class="line">  server.<span class="built_in">sin</span>\_addr.S\_un.S\_addr = inet\_addr(SERVER_ADDRESS);</span><br><span class="line">  server.sin_port = htons(PORT);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">connect</span>(sClient, (struct sockaddr *)&amp;server, <span class="keyword">sizeof</span>(SOCKADDR_IN));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Send:"</span>);</span><br><span class="line">  gets(szMessage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Send message</span></span><br><span class="line">    send(sClient, szMessage, <span class="built_in">strlen</span>(szMessage), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Receive message</span></span><br><span class="line">    ret = recv(sClient, szMessage, MSGSIZE, <span class="number">0</span>);</span><br><span class="line">    szMessage\[ret\] = '\\0';</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Received \[%d bytes\]: '%s'\\n"</span>, ret, szMessage);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean up</span></span><br><span class="line">  closesocket(sClient);</span><br><span class="line">  WSACleanup();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端所做的事情相当简单，创建套接字，连接服务器，然后不停的发送和接收数据。 比 较容易想到的一种服务器模型就是采用一个主线程，负责监听客户端的连接请求，当接收到某个客户端的连接请求后，创建一个专门用于和该客户端通信的套接字和 一个辅助线程。以后该客户端和服务器的交互都在这个辅助线程内完成。这种方法比较直观，程序非常简单而且可移植性好，但是不能利用平台相关的特性。例如， 如果连接数增多的时候（成千上万的连接），那么线程数成倍增长，操作系统忙于频繁的线程间切换，而且大部分线程在其生命周期内都是处于非活动状态的，这大 大浪费了系统的资源。所以，如果你已经知道你的代码只会运行在Windows平台上，建议采用Winsock I/O模型。 一.选择模型 Select（选 择）模型是Winsock中最常见的I/O模型。之所以称其为“Select模型”，是由于它的“中心思想”便是利用select函数，实现对I/O的管 理。最初设计该模型时，主要面向的是某些使用UNIX操作系统的计算机，它们采用的是Berkeley套接字方案。Select模型已集成到 Winsock 1.1中，它使那些想避免在套接字调用过程中被无辜“锁定”的应用程序，采取一种有序的方式，同时进行对多个套接字的管理。由于 Winsock 1.1向后兼容于Berkeley套接字实施方案，所以假如有一个Berkeley套接字应用使用了select函数，那么从理论角度 讲，毋需对其进行任何修改，便可正常运行。（节选自《Windows网络编程》第八章) 下面的这段程序就是利用选择模型实现的Echo服务器的代码（已经不能再精简了）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT       5150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE    1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>    g_iTotalConn = <span class="number">0</span>;</span><br><span class="line">SOCKET g\_CliSocketArr\[FD\_SETSIZE\];</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParameter)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WSADATA     wsaData;</span><br><span class="line">  SOCKET      sListen, sClient;</span><br><span class="line">  SOCKADDR_IN local, client;</span><br><span class="line">  <span class="keyword">int</span>         iaddrSize = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">  DWORD       dwThreadId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize Windows socket library</span></span><br><span class="line">  WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create listening socket</span></span><br><span class="line">  sListen = socket(AF\_INET, SOCK\_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bind</span></span><br><span class="line">  local.<span class="built_in">sin</span>\_addr.S\_un.S\_addr = htonl(INADDR\_ANY);</span><br><span class="line">local.<span class="built_in">sin</span>\_family = AF\_INET;</span><br><span class="line">local.sin_port = htons(PORT);</span><br><span class="line">  bind(sListen, (struct sockaddr *)&amp;local, <span class="keyword">sizeof</span>(SOCKADDR_IN));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Listen</span></span><br><span class="line">  <span class="built_in">listen</span>(sListen, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create worker thread</span></span><br><span class="line">  CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadId);  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Accept a connection</span></span><br><span class="line">    sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepted client:%s:%d\\n"</span>, inet\_ntoa(client.<span class="built_in">sin</span>\_addr), ntohs(client.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add socket to g_CliSocketArr</span></span><br><span class="line">    g\_CliSocketArr\[g\_iTotalConn++\] = sClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>            i;</span><br><span class="line">  fd_set         fdread;</span><br><span class="line">  <span class="keyword">int</span>            ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span> = &#123;</span><span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span>           szMessage\[MSGSIZE\];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    FD_ZERO(&amp;fdread);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_iTotalConn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      FD\_SET(g\_CliSocketArr, &amp;fdread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We only care read event</span></span><br><span class="line">    ret = select(<span class="number">0</span>, &amp;fdread, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Time expired</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_iTotalConn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (FD\_ISSET(g\_CliSocketArr, &amp;fdread))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// A read event happened on g_CliSocketArr</span></span><br><span class="line">        ret = recv(g_CliSocketArr, szMessage, MSGSIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span> || (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() == WSAECONNRESET))</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">// Client socket closed</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Client socket %d closed.\\n"</span>, g_CliSocketArr);</span><br><span class="line">     closesocket(g_CliSocketArr);</span><br><span class="line">     <span class="keyword">if</span> (i &lt; g_iTotalConn - <span class="number">1</span>)</span><br><span class="line">          &#123;            </span><br><span class="line">            g\_CliSocketArr\[i--\] = g\_CliSocketArr\[--g_iTotalConn\];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">// We received a message from client</span></span><br><span class="line">          szMessage\[ret\] = '\\0';</span><br><span class="line">     send(g_CliSocketArr, szMessage, <span class="built_in">strlen</span>(szMessage), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器的几个主要动作如下： 1.创建监听套接字，绑定，监听； 2.创建工作者线程； 3.创建一个套接字数组，用来存放当前所有活动的客户端套接字，每accept一个连接就更新一次数组； 4. 接受客户端的连接。这里有一点需要注意的，就是我没有重新定义FD_SETSIZE宏，所以服务器最多支持的并发连接数为64。而且，这里决不能无条件的 accept,服务器应该根据当前的连接数来决定是否接受来自某个客户端的连接。一种比较好的实现方案就是采用WSAAccept函数，而且让 WSAAccept回调自己实现的Condition Function。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> CALLBACK <span class="title">ConditionFunc</span><span class="params">(LPWSABUF lpCallerId,LPWSABUF lpCallerData, LPQOS lpSQOS,LPQOS lpGQOS,LPWSABUF lpCalleeId, LPWSABUF lpCalleeData,GROUP FAR * g,DWORD dwCallbackData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (当前连接数 &lt; FD_SETSIZE)</span><br><span class="line">  <span class="keyword">return</span> CF_ACCEPT;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">return</span> CF_REJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作者线程里面是一个死循环，一次循环完成的动作是： 1.将当前所有的客户端套接字加入到读集fdread中； 2.调用select函数； 3. 查看某个套接字是否仍然处于读集中，如果是，则接收数据。如果接收的数据长度为0，或者发生WSAECONNRESET错误，则表示客户端套接字主动关 闭，这时需要将服务器中对应的套接字所绑定的资源释放掉，然后调整我们的套接字数组（将数组中最后一个套接字挪到当前的位置上） 除了需要有条件接受客户端的连接外，还需要在连接数为0的情形下做特殊处理，因为如果读集中没有任何套接字，select函数会立刻返回，这将导致工作者线程成为一个毫无停顿的死循环，CPU的占用率马上达到100%。 关 系到套接字列表的操作都需要使用循环,在轮询的时候,需要遍历一次,再新的一轮开始时,将列表加入队列又需要遍历一次.也就是说,Select在工作一次 时,需要至少遍历2次列表,这是它效率较低的原因之一.在大规模的网络连接方面,还是推荐使用IOCP或EPOLL模型.但是Select模型可以使用在 诸如对战类游戏上,比如类似星际这种,因为它小巧易于实现,而且对战类游戏的网络连接量并不大. 对于Select模型想要突破 Windows 64个限制的话,可以采取分段轮询,一次轮询64个.例如套接字列表为128个,在第一次轮询时,将前64个放入队列中用Select进 行状态查询,待本次操作全部结束后.将后64个再加入轮询队列中进行轮询处理.这样处理需要在非阻塞式下工作.以此类推,Select也能支持无限多个. 二.异步选择 Winsock提供了一个有用的异步I/O模型。利用这个模型，应用程序可在一个套接字上，接收以Windows消息为基础的网络事件通知。<strong>具体的做法是在建好一个套接字后，调用WSAAsyncSelect函数。</strong> 该 模型最早出现于Winsock的1.1版本中，用于帮助应用程序开发者面向一些早期的16位Windows平台（如 Windows for Workgroups），适应其“落后”的多任务消息环境。应用程序仍可从这种模型中得到好处，特别是它们用一个标准的 Windows例程（常称为”WndProc”），对窗口消息进行管理的时候。该模型亦得到了Microsoft Foundation Class（微 软基本类，MFC）对象CSocket的采纳。（节选自《Windows网络编程》第八章) 我还是先贴出代码，然后做详细解释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT      5150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE   1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WM\_SOCKET WM\_USER+0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND, UINT, WPARAM, LPARAM)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="keyword">int</span> iCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> TCHAR szAppName\[\] = _T(<span class="string">"AsyncSelect Model"</span>);</span><br><span class="line">  HWND         hwnd ;</span><br><span class="line">  MSG          msg ;</span><br><span class="line">  WNDCLASS     wndclass ;</span><br><span class="line"></span><br><span class="line">  wndclass.style         = CS\_HREDRAW | CS\_VREDRAW ;</span><br><span class="line">  wndclass.lpfnWndProc   = WndProc ;</span><br><span class="line">  wndclass.cbClsExtra    = <span class="number">0</span> ;</span><br><span class="line">  wndclass.cbWndExtra    = <span class="number">0</span> ;</span><br><span class="line">  wndclass.hInstance     = hInstance ;</span><br><span class="line">  wndclass.hIcon         = LoadIcon (<span class="literal">NULL</span>, IDI_APPLICATION) ;</span><br><span class="line">  wndclass.hCursor       = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW) ;</span><br><span class="line">  wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;</span><br><span class="line">  wndclass.lpszMenuName  = <span class="literal">NULL</span> ;</span><br><span class="line">  wndclass.lpszClassName = szAppName ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!RegisterClass(&amp;wndclass))</span><br><span class="line">  &#123;</span><br><span class="line">    MessageBox (<span class="literal">NULL</span>, TEXT (<span class="string">"This program requires Windows NT!"</span>), szAppName, MB_ICONERROR) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hwnd = CreateWindow (szAppName,                  <span class="comment">// window class name</span></span><br><span class="line">                       TEXT (<span class="string">"AsyncSelect Model"</span>), <span class="comment">// window caption</span></span><br><span class="line">                       WS_OVERLAPPEDWINDOW,        <span class="comment">// window style</span></span><br><span class="line">                       CW_USEDEFAULT,              <span class="comment">// initial x position</span></span><br><span class="line">                       CW_USEDEFAULT,              <span class="comment">// initial y position</span></span><br><span class="line">                       CW_USEDEFAULT,              <span class="comment">// initial x size</span></span><br><span class="line">                       CW_USEDEFAULT,              <span class="comment">// initial y size</span></span><br><span class="line">                       <span class="literal">NULL</span>,                       <span class="comment">// parent window handle</span></span><br><span class="line">                       <span class="literal">NULL</span>,                       <span class="comment">// window menu handle</span></span><br><span class="line">                       hInstance,                  <span class="comment">// program instance handle</span></span><br><span class="line">                       <span class="literal">NULL</span>) ;                     <span class="comment">// creation parameters</span></span><br><span class="line"></span><br><span class="line">  ShowWindow(hwnd, iCmdShow);</span><br><span class="line">  UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    TranslateMessage(&amp;msg) ;</span><br><span class="line">    DispatchMessage(&amp;msg) ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span> <span class="params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WSADATA       wsd;</span><br><span class="line">  <span class="keyword">static</span> SOCKET sListen;</span><br><span class="line">  SOCKET        sClient;</span><br><span class="line">  SOCKADDR_IN   local, client;</span><br><span class="line">  <span class="keyword">int</span>           ret, iAddrSize = <span class="keyword">sizeof</span>(client);</span><br><span class="line">  <span class="keyword">char</span>          szMessage\[MSGSIZE\];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (message)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">    <span class="comment">// Initialize Windows Socket library</span></span><br><span class="line">  WSAStartup(<span class="number">0x0202</span>, &amp;wsd);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create listening socket</span></span><br><span class="line">    sListen = socket(AF\_INET, SOCK\_STREAM, IPPROTO_TCP);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Bind</span></span><br><span class="line">    local.<span class="built_in">sin</span>\_addr.S\_un.S\_addr = htonl(INADDR\_ANY);</span><br><span class="line">  local.<span class="built_in">sin</span>\_family = AF\_INET;</span><br><span class="line">  local.sin_port = htons(PORT);</span><br><span class="line">  bind(sListen, (struct sockaddr *)&amp;local, <span class="keyword">sizeof</span>(local));</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Listen</span></span><br><span class="line">    <span class="built_in">listen</span>(sListen, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate listening socket with FD_ACCEPT event</span></span><br><span class="line">  WSAAsyncSelect(sListen, hwnd, WM\_SOCKET, FD\_ACCEPT);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">    closesocket(sListen);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> WM_SOCKET:</span><br><span class="line">    <span class="keyword">if</span> (WSAGETSELECTERROR(lParam))</span><br><span class="line">    &#123;</span><br><span class="line">      closesocket(wParam);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (WSAGETSELECTEVENT(lParam))</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FD_ACCEPT:</span><br><span class="line">      <span class="comment">// Accept a connection from client</span></span><br><span class="line">      sClient = accept(wParam, (struct sockaddr *)&amp;client, &amp;iAddrSize);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Associate client socket with FD\_READ and FD\_CLOSE event</span></span><br><span class="line">      WSAAsyncSelect(sClient, hwnd, WM\_SOCKET, FD\_READ | FD_CLOSE);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FD_READ:</span><br><span class="line">      ret = recv(wParam, szMessage, MSGSIZE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ret == <span class="number">0</span> || ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() == WSAECONNRESET)</span><br><span class="line">      &#123;</span><br><span class="line">        closesocket(wParam);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        szMessage\[ret\] = '\\0';</span><br><span class="line">        send(wParam, szMessage, <span class="built_in">strlen</span>(szMessage), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">case</span> FD_CLOSE:</span><br><span class="line">      closesocket(wParam);      </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我看来，WSAAsyncSelect是最简单的一种Winsock I/O模型（之所以说它简单是因为一个主线程就搞定了）。使用Raw Windows API写过窗口类应用程序的人应该都能看得懂。这里，我们需要做的仅仅是： 1.在WM_CREATE消息处理函数中，初始化Windows Socket library，创建监听套接字，绑定，监听，并且调用WSAAsyncSelect函数表示我们关心在监听套接字上发生的FD_ACCEPT事件； 2.自定义一个消息WM_SOCKET，一旦在我们所关心的套接字（监听套接字和客户端套接字）上发生了某个事件，系统就会调用WndProc并且message参数被设置为WM_SOCKET； 3.在WM_SOCKET的消息处理函数中，分别对FD_ACCEPT、FD_READ和FD_CLOSE事件进行处理； 4.在窗口销毁消息(WM_DESTROY)的处理函数中，我们关闭监听套接字，清除Windows Socket library 下面这张用于WSAAsyncSelect函数的网络事件类型表可以让你对各个网络事件有更清楚的认识： 表1 FD_READ 应用程序想要接收有关是否可读的通知，以便读入数据 FD_WRITE 应用程序想要接收有关是否可写的通知，以便写入数据 FD_OOB 应用程序想接收是否有带外（OOB）数据抵达的通知 FD_ACCEPT 应用程序想接收与进入连接有关的通知 FD_CONNECT 应用程序想接收与一次连接或者多点join操作完成的通知 FD_CLOSE 应用程序想接收与套接字关闭有关的通知 FD_QOS 应用程序想接收套接字“服务质量”（QoS）发生更改的通知 FD_GROUP_QOS  应用程序想接收套接字组“服务质量”发生更改的通知（现在没什么用处，为未来套接字组的使用保留） FD_ROUTING_INTERFACE_CHANGE 应用程序想接收在指定的方向上，与路由接口发生变化的通知 FD_ADDRESS_LIST_CHANGE  应用程序想接收针对套接字的协议家族，本地地址列表发生变化的通知 三.事件选择 Winsock 提供了另一个有用的异步I/O模型。和WSAAsyncSelect模型类似的是，它也允许应用程序在一个或多个套接字上，接收以事件为基础的网络事件通 知。对于表1总结的、由WSAAsyncSelect模型采用的网络事件来说，它们均可原封不动地移植到新模型。在用新模型开发的应用程序中，也能接收和 处理所有那些事件。该模型最主要的差别在于网络事件会投递至一个事件对象句柄，而非投递至一个窗口例程。（节选自《Windows网络编程》第八章) 还是让我们先看代码然后进行分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT    5150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>      g_iTotalConn = <span class="number">0</span>;</span><br><span class="line">SOCKET   g\_CliSocketArr\[MAXIMUM\_WAIT_OBJECTS\];</span><br><span class="line">WSAEVENT g\_CliEventArr\[MAXIMUM\_WAIT_OBJECTS\];</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WSADATA     wsaData;</span><br><span class="line">  SOCKET      sListen, sClient;</span><br><span class="line">  SOCKADDR_IN local, client;</span><br><span class="line">  DWORD       dwThreadId;</span><br><span class="line">  <span class="keyword">int</span>         iaddrSize = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize Windows Socket library</span></span><br><span class="line">  WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create listening socket</span></span><br><span class="line">  sListen = socket(AF\_INET, SOCK\_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bind</span></span><br><span class="line">  local.<span class="built_in">sin</span>\_addr.S\_un.S\_addr = htonl(INADDR\_ANY);</span><br><span class="line">local.<span class="built_in">sin</span>\_family = AF\_INET;</span><br><span class="line">local.sin_port = htons(PORT);</span><br><span class="line">  bind(sListen, (struct sockaddr *)&amp;local, <span class="keyword">sizeof</span>(SOCKADDR_IN));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Listen</span></span><br><span class="line">  <span class="built_in">listen</span>(sListen, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create worker thread</span></span><br><span class="line">  CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Accept a connection</span></span><br><span class="line">    sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepted client:%s:%d\\n"</span>, inet\_ntoa(client.<span class="built_in">sin</span>\_addr), ntohs(client.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate socket with network event</span></span><br><span class="line">    g\_CliSocketArr\[g\_iTotalConn\] = sClient;</span><br><span class="line">    g\_CliEventArr\[g\_iTotalConn\] = WSACreateEvent();</span><br><span class="line">    WSAEventSelect(g\_CliSocketArr\[g\_iTotalConn\],</span><br><span class="line">                   g\_CliEventArr\[g\_iTotalConn\],</span><br><span class="line">                   FD\_READ | FD\_CLOSE);</span><br><span class="line">    g_iTotalConn++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>              ret, index;</span><br><span class="line">  WSANETWORKEVENTS NetworkEvents;</span><br><span class="line">  <span class="keyword">char</span>             szMessage\[MSGSIZE\];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = WSAWaitForMultipleEvents(g\_iTotalConn, g\_CliEventArr, FALSE, <span class="number">1000</span>, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (ret == WSA\_WAIT\_FAILED || ret == WSA\_WAIT\_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index = ret - WSA\_WAIT\_EVENT_0;</span><br><span class="line">    WSAEnumNetworkEvents(g\_CliSocketArr\[index\], g\_CliEventArr\[index\], &amp;NetworkEvents);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NetworkEvents.lNetworkEvents &amp; FD_READ)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Receive message from client</span></span><br><span class="line">      ret = recv(g_CliSocketArr\[index\], szMessage, MSGSIZE, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (ret == <span class="number">0</span> || (ret == SOCKET_ERROR &amp;&amp; WSAGetLastError() == WSAECONNRESET))</span><br><span class="line">      &#123;</span><br><span class="line">        Cleanup(index);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        szMessage\[ret\] = '\\0';</span><br><span class="line">        send(g_CliSocketArr\[index\], szMessage, <span class="built_in">strlen</span>(szMessage), <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NetworkEvents.lNetworkEvents &amp; FD_CLOSE)</span><br><span class="line">  &#123;</span><br><span class="line">   Cleanup(index);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  closesocket(g_CliSocketArr\[index\]);</span><br><span class="line">WSACloseEvent(g_CliEventArr\[index\]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index &lt; g_iTotalConn - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  g\_CliSocketArr\[index\] = g\_CliSocketArr\[g_iTotalConn - <span class="number">1</span>\];</span><br><span class="line">  g\_CliEventArr\[index\] = g\_CliEventArr\[g_iTotalConn - <span class="number">1</span>\];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g_iTotalConn--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事 件选择模型也比较简单，实现起来也不是太复杂，它的基本思想是将每个套接字都和一个WSAEVENT对象对应起来，并且在关联的时候指定需要关注的哪些网 络事件。一旦在某个套接字上发生了我们关注的事件（FD_READ和FD_CLOSE），与之相关联的WSAEVENT对象被Signaled。程序定义 了两个全局数组，一个套接字数组，一个WSAEVENT对象数组，其大小都是MAXIMUM_WAIT_OBJECTS（64），两个数组中的元素一一对 应。 同样的，这里的程序没有考虑两个问题，一是不能无条件的调用accept，因为我们支持的并发连接数有限。解决方法是将套接字按 MAXIMUM_WAIT_OBJECTS分组，每MAXIMUM_WAIT_OBJECTS个套接字一组，每一组分配一个工作者线程；或者采用 WSAAccept代替accept，并回调自己定义的Condition Function。第二个问题是没有对连接数为0的情形做特殊处理，程序在连 接数为0的时候CPU占用率为100%。 四.重叠I/O模型 Winsock2的发布使得Socket I/O有了和文件I/O统 一的接口。我们可以通过使用Win32文件操纵函数ReadFile和WriteFile来进行Socket I/O。伴随而来的，用于普通文件I/O的 重叠I/O模型和完成端口模型对Socket I/O也适用了。这些模型的优点是可以达到更佳的系统性能，但是实现较为复杂，里面涉及较多的C语言技巧。 例如我们在完成端口模型中会经常用到所谓的“尾随数据”。 1.用事件通知方式实现的重叠I/O模型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT    5150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  WSAOVERLAPPED overlap;</span><br><span class="line">  WSABUF        Buffer;</span><br><span class="line">  <span class="keyword">char</span>          szMessage\[MSGSIZE\];</span><br><span class="line">  DWORD         NumberOfBytesRecvd;</span><br><span class="line">  DWORD         Flags;</span><br><span class="line">&#125;PER\_IO\_OPERATION\_DATA, *LPPER\_IO\_OPERATION\_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>                     g_iTotalConn = <span class="number">0</span>;</span><br><span class="line">SOCKET                  g\_CliSocketArr\[MAXIMUM\_WAIT_OBJECTS\];</span><br><span class="line">WSAEVENT                g\_CliEventArr\[MAXIMUM\_WAIT_OBJECTS\];</span><br><span class="line">LPPER\_IO\_OPERATION\_DATA g\_pPerIODataArr\[MAXIMUM\_WAIT\_OBJECTS\];</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WSADATA     wsaData;</span><br><span class="line">  SOCKET      sListen, sClient;</span><br><span class="line">  SOCKADDR_IN local, client;</span><br><span class="line">  DWORD       dwThreadId;</span><br><span class="line">  <span class="keyword">int</span>         iaddrSize = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize Windows Socket library</span></span><br><span class="line">  WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create listening socket</span></span><br><span class="line">  sListen = socket(AF\_INET, SOCK\_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bind</span></span><br><span class="line">  local.<span class="built_in">sin</span>\_addr.S\_un.S\_addr = htonl(INADDR\_ANY);</span><br><span class="line">local.<span class="built_in">sin</span>\_family = AF\_INET;</span><br><span class="line">local.sin_port = htons(PORT);</span><br><span class="line">  bind(sListen, (struct sockaddr *)&amp;local, <span class="keyword">sizeof</span>(SOCKADDR_IN));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Listen</span></span><br><span class="line">  <span class="built_in">listen</span>(sListen, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create worker thread</span></span><br><span class="line">  CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Accept a connection</span></span><br><span class="line">    sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepted client:%s:%d\\n"</span>, inet\_ntoa(client.<span class="built_in">sin</span>\_addr), ntohs(client.sin_port));</span><br><span class="line"></span><br><span class="line">    g\_CliSocketArr\[g\_iTotalConn\] = sClient;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Allocate a PER\_IO\_OPERATION_DATA structure</span></span><br><span class="line">    g\_pPerIODataArr\[g\_iTotalConn\] = (LPPER\_IO\_OPERATION_DATA)HeapAlloc(</span><br><span class="line">      GetProcessHeap(),</span><br><span class="line">      HEAP\_ZERO\_MEMORY,</span><br><span class="line">      <span class="keyword">sizeof</span>(PER\_IO\_OPERATION_DATA));</span><br><span class="line">    g\_pPerIODataArr\[g\_iTotalConn\]-&gt;Buffer.len = MSGSIZE;</span><br><span class="line">    g\_pPerIODataArr\[g\_iTotalConn\]-&gt;Buffer.buf = g\_pPerIODataArr\[g\_iTotalConn\]-&gt;szMessage;</span><br><span class="line">    g\_CliEventArr\[g\_iTotalConn\] = g\_pPerIODataArr\[g\_iTotalConn\]-&gt;overlap.hEvent = WSACreateEvent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch an asynchronous operation</span></span><br><span class="line">    WSARecv(</span><br><span class="line">      g\_CliSocketArr\[g\_iTotalConn\],</span><br><span class="line">      &amp;g\_pPerIODataArr\[g\_iTotalConn\]-&gt;Buffer,</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      &amp;g\_pPerIODataArr\[g\_iTotalConn\]-&gt;NumberOfBytesRecvd,</span><br><span class="line">      &amp;g\_pPerIODataArr\[g\_iTotalConn\]-&gt;Flags,</span><br><span class="line">      &amp;g\_pPerIODataArr\[g\_iTotalConn\]-&gt;overlap,</span><br><span class="line">      <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    g_iTotalConn++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  closesocket(sListen);</span><br><span class="line">  WSACleanup();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span>   ret, index;</span><br><span class="line">  DWORD cbTransferred;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    ret = WSAWaitForMultipleEvents(g\_iTotalConn, g\_CliEventArr, FALSE, <span class="number">1000</span>, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (ret == WSA\_WAIT\_FAILED || ret == WSA\_WAIT\_TIMEOUT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index = ret - WSA\_WAIT\_EVENT_0;</span><br><span class="line">    WSAResetEvent(g_CliEventArr\[index\]);</span><br><span class="line"></span><br><span class="line">    WSAGetOverlappedResult(</span><br><span class="line">      g_CliSocketArr\[index\],</span><br><span class="line">      &amp;g_pPerIODataArr\[index\]-&gt;overlap,</span><br><span class="line">      &amp;cbTransferred,</span><br><span class="line">      TRUE,</span><br><span class="line">      &amp;g\_pPerIODataArr\[g\_iTotalConn\]-&gt;Flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cbTransferred == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// The connection was closed by client</span></span><br><span class="line">      Cleanup(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// g_pPerIODataArr\[index\]-&gt;szMessage contains the received data</span></span><br><span class="line">      g_pPerIODataArr\[index\]-&gt;szMessage\[cbTransferred\] = '\\0';</span><br><span class="line">      send(g\_CliSocketArr\[index\], g\_pPerIODataArr\[index\]-&gt;szMessage,\</span><br><span class="line">        cbTransferred, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Launch another asynchronous operation</span></span><br><span class="line">      WSARecv(</span><br><span class="line">        g_CliSocketArr\[index\],</span><br><span class="line">        &amp;g_pPerIODataArr\[index\]-&gt;Buffer,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        &amp;g_pPerIODataArr\[index\]-&gt;NumberOfBytesRecvd,</span><br><span class="line">        &amp;g_pPerIODataArr\[index\]-&gt;Flags,</span><br><span class="line">        &amp;g_pPerIODataArr\[index\]-&gt;overlap,</span><br><span class="line">        <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  closesocket(g_CliSocketArr\[index\]);</span><br><span class="line">  WSACloseEvent(g_CliEventArr\[index\]);</span><br><span class="line">  HeapFree(GetProcessHeap(), <span class="number">0</span>, g_pPerIODataArr\[index\]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &lt; g_iTotalConn - <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    g\_CliSocketArr\[index\] = g\_CliSocketArr\[g_iTotalConn - <span class="number">1</span>\];</span><br><span class="line">    g\_CliEventArr\[index\] = g\_CliEventArr\[g_iTotalConn - <span class="number">1</span>\];</span><br><span class="line">    g\_pPerIODataArr\[index\] = g\_pPerIODataArr\[g_iTotalConn - <span class="number">1</span>\];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  g\_pPerIODataArr\[--g\_iTotalConn\] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这 个模型与上述其他模型不同的是它使用Winsock2提供的异步I/O函数WSARecv。在调用WSARecv时，指定一个WSAOVERLAPPED 结构，这个调用不是阻塞的，也就是说，它会立刻返回。一旦有数据到达的时候，被指定的WSAOVERLAPPED结构中的hEvent被 Signaled。由于下面这个语句 g_CliEventArr[g_iTotalConn] = g_pPerIODataArr[g_iTotalConn]-&gt;overlap.hEvent； 使 得与该套接字相关联的WSAEVENT对象也被Signaled，所以WSAWaitForMultipleEvents的调用操作成功返回。我们现在应 该做的就是用与调用WSARecv相同的WSAOVERLAPPED结构为参数调用WSAGetOverlappedResult，从而得到本次I/O传 送的字节数等相关信息。在取得接收的数据后，把数据原封不动的发送到客户端，然后重新激活一个WSARecv异步操作。 2.用完成例程方式实现的重叠I/O模型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WINSOCK2.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT    5150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WSAOVERLAPPED overlap;</span><br><span class="line">WSABUF        Buffer;</span><br><span class="line">  <span class="keyword">char</span>          szMessage\[MSGSIZE\];</span><br><span class="line">DWORD         NumberOfBytesRecvd;</span><br><span class="line">DWORD         Flags; </span><br><span class="line">SOCKET        sClient;</span><br><span class="line">&#125;PER\_IO\_OPERATION\_DATA, *LPPER\_IO\_OPERATION\_DATA;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">CompletionROUTINE</span><span class="params">(DWORD, DWORD, LPWSAOVERLAPPED, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line">SOCKET g_sNewClientConnection;</span><br><span class="line">BOOL   g_bNewConnectionArrived = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WSADATA     wsaData;</span><br><span class="line">  SOCKET      sListen;</span><br><span class="line">  SOCKADDR_IN local, client;</span><br><span class="line">  DWORD       dwThreadId;</span><br><span class="line">  <span class="keyword">int</span>         iaddrSize = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize Windows Socket library</span></span><br><span class="line">  WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create listening socket</span></span><br><span class="line">  sListen = socket(AF\_INET, SOCK\_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bind</span></span><br><span class="line">  local.<span class="built_in">sin</span>\_addr.S\_un.S\_addr = htonl(INADDR\_ANY);</span><br><span class="line">local.<span class="built_in">sin</span>\_family = AF\_INET;</span><br><span class="line">local.sin_port = htons(PORT);</span><br><span class="line">  bind(sListen, (struct sockaddr *)&amp;local, <span class="keyword">sizeof</span>(SOCKADDR_IN));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Listen</span></span><br><span class="line">  <span class="built_in">listen</span>(sListen, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create worker thread</span></span><br><span class="line">  CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Accept a connection</span></span><br><span class="line">    g_sNewClientConnection = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);</span><br><span class="line">    g_bNewConnectionArrived = TRUE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepted client:%s:%d\\n"</span>, inet\_ntoa(client.<span class="built_in">sin</span>\_addr), ntohs(client.sin_port));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPPER\_IO\_OPERATION_DATA lpPerIOData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_bNewConnectionArrived)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Launch an asynchronous operation for new arrived connection</span></span><br><span class="line">      lpPerIOData = (LPPER\_IO\_OPERATION_DATA)HeapAlloc(</span><br><span class="line">        GetProcessHeap(),</span><br><span class="line">        HEAP\_ZERO\_MEMORY,</span><br><span class="line">        <span class="keyword">sizeof</span>(PER\_IO\_OPERATION_DATA));</span><br><span class="line">      lpPerIOData-&gt;Buffer.len = MSGSIZE;</span><br><span class="line">      lpPerIOData-&gt;Buffer.buf = lpPerIOData-&gt;szMessage;</span><br><span class="line">      lpPerIOData-&gt;sClient = g_sNewClientConnection;</span><br><span class="line">      </span><br><span class="line">      WSARecv(lpPerIOData-&gt;sClient,</span><br><span class="line">        &amp;lpPerIOData-&gt;Buffer,</span><br><span class="line">        <span class="number">1</span>,</span><br><span class="line">        &amp;lpPerIOData-&gt;NumberOfBytesRecvd,</span><br><span class="line">        &amp;lpPerIOData-&gt;Flags,</span><br><span class="line">        &amp;lpPerIOData-&gt;overlap,</span><br><span class="line">        CompletionROUTINE);      </span><br><span class="line">      </span><br><span class="line">      g_bNewConnectionArrived = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SleepEx(<span class="number">1000</span>, TRUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> CALLBACK <span class="title">CompletionROUTINE</span><span class="params">(DWORD dwError,</span></span></span><br><span class="line"><span class="function"><span class="params">                                DWORD cbTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">                                LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">                                DWORD dwFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  LPPER\_IO\_OPERATION\_DATA lpPerIOData = (LPPER\_IO\_OPERATION\_DATA)lpOverlapped;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (dwError != <span class="number">0</span> || cbTransferred == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Connection was closed by client</span></span><br><span class="line">  closesocket(lpPerIOData-&gt;sClient);</span><br><span class="line">  HeapFree(GetProcessHeap(), <span class="number">0</span>, lpPerIOData);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    lpPerIOData-&gt;szMessage\[cbTransferred\] = '\\0';</span><br><span class="line">    send(lpPerIOData-&gt;sClient, lpPerIOData-&gt;szMessage, cbTransferred, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Launch another asynchronous operation</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;lpPerIOData-&gt;overlap, <span class="number">0</span>, <span class="keyword">sizeof</span>(WSAOVERLAPPED));</span><br><span class="line">    lpPerIOData-&gt;Buffer.len = MSGSIZE;</span><br><span class="line">    lpPerIOData-&gt;Buffer.buf = lpPerIOData-&gt;szMessage;    </span><br><span class="line"></span><br><span class="line">    WSARecv(lpPerIOData-&gt;sClient,</span><br><span class="line">      &amp;lpPerIOData-&gt;Buffer,</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      &amp;lpPerIOData-&gt;NumberOfBytesRecvd,</span><br><span class="line">      &amp;lpPerIOData-&gt;Flags,</span><br><span class="line">      &amp;lpPerIOData-&gt;overlap,</span><br><span class="line">      CompletionROUTINE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 完成例程来实现重叠I/O比用事件通知简单得多。在这个模型中，主线程只用不停的接受连接即可；辅助线程判断有没有新的客户端连接被建立，如果有，就为那 个客户端套接字激活一个异步的WSARecv操作，然后调用SleepEx使线程处于一种可警告的等待状态，以使得I/O完成后 CompletionROUTINE可以被内核调用。如果辅助线程不调用SleepEx，则内核在完成一次I/O操作后，无法调用完成例程（因为完成例程 的运行应该和当初激活WSARecv异步操作的代码在同一个线程之内）。 完成例程内的实现代码比较简单，它取出接收到的数据，然后将数据原封不动 的发送给客户端，最后重新激活另一个WSARecv异步操作。注意，在这里用到了“尾随数据”。我们在调用WSARecv的时候，参数 lpOverlapped实际上指向一个比它大得多的结构PER_IO_OPERATION_DATA，这个结构除了WSAOVERLAPPED以外，还 被我们附加了缓冲区的结构信息，另外还包括客户端套接字等重要的信息。这样，在完成例程中通过参数lpOverlapped拿到的不仅仅是 WSAOVERLAPPED结构，还有后边尾随的包含客户端套接字和接收数据缓冲区等重要信息。这样的C语言技巧在我后面介绍完成端口的时候还会使用到。 五.完成端口模型 “完 成端口”模型是迄今为止最为复杂的一种I/O模型。然而，假若一个应用程序同时需要管理为数众多的套接字，那么采用这种模型，往往可以达到最佳的系统性 能！但不幸的是，该模型只适用于Windows NT和Windows 2000操作系统。因其设计的复杂性，只有在你的应用程序需要同时管理数百乃至上 千个套接字的时候，而且希望随着系统内安装的CPU数量的增多，应用程序的性能也可以线性提升，才应考虑采用“完成端口”模型。要记住的一个基本准则是， 假如要为Windows NT或Windows 2000开发高性能的服务器应用，同时希望为大量套接字I/O请求提供服务（Web服务器便是这方面的典 型例子），那么I/O完成端口模型便是最佳选择！（节选自《Windows网络编程》第八章） 完成端口模型是我最喜爱的一种模型。虽然其实现比较 复杂（其实我觉得它的实现比用事件通知实现的重叠I/O简单多了），但其效率是惊人的。我在T公司的时候曾经帮同事写过一个邮件服务器的性能测试程序，用 的就是完成端口模型。结果表明，完成端口模型在多连接（成千上万）的情况下，仅仅依靠一两个辅助线程，就可以达到非常高的吞吐量。下面我还是从代码说起：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WINSOCK2.H&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT    5150</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSGSIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"ws2_32.lib"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  RECV_POSTED</span><br><span class="line">&#125;OPERATION_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">WSAOVERLAPPED  overlap;</span><br><span class="line">WSABUF         Buffer;</span><br><span class="line">  <span class="keyword">char</span>           szMessage\[MSGSIZE\];</span><br><span class="line">DWORD          NumberOfBytesRecvd;</span><br><span class="line">DWORD          Flags;</span><br><span class="line">OPERATION_TYPE OperationType;</span><br><span class="line">&#125;PER\_IO\_OPERATION\_DATA, *LPPER\_IO\_OPERATION\_DATA;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WSADATA                 wsaData;</span><br><span class="line">  SOCKET                  sListen, sClient;</span><br><span class="line">  SOCKADDR_IN             local, client;</span><br><span class="line">  DWORD                   i, dwThreadId;</span><br><span class="line">  <span class="keyword">int</span>                     iaddrSize = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">  HANDLE                  CompletionPort = INVALID\_HANDLE\_VALUE;</span><br><span class="line">  SYSTEM_INFO             systeminfo;</span><br><span class="line">  LPPER\_IO\_OPERATION_DATA lpPerIOData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize Windows Socket library</span></span><br><span class="line">  WSAStartup(<span class="number">0x0202</span>, &amp;wsaData);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create completion port</span></span><br><span class="line">  CompletionPort = CreateIoCompletionPort(INVALID\_HANDLE\_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create worker thread</span></span><br><span class="line">  GetSystemInfo(&amp;systeminfo);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; systeminfo.dwNumberOfProcessors; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, WorkerThread, CompletionPort, <span class="number">0</span>, &amp;dwThreadId);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Create listening socket</span></span><br><span class="line">  sListen = socket(AF\_INET, SOCK\_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Bind</span></span><br><span class="line">  local.<span class="built_in">sin</span>\_addr.S\_un.S\_addr = htonl(INADDR\_ANY);</span><br><span class="line">local.<span class="built_in">sin</span>\_family = AF\_INET;</span><br><span class="line">local.sin_port = htons(PORT);</span><br><span class="line">  bind(sListen, (struct sockaddr *)&amp;local, <span class="keyword">sizeof</span>(SOCKADDR_IN));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Listen</span></span><br><span class="line">  <span class="built_in">listen</span>(sListen, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Accept a connection</span></span><br><span class="line">    sClient = accept(sListen, (struct sockaddr *)&amp;client, &amp;iaddrSize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Accepted client:%s:%d\\n"</span>, inet\_ntoa(client.<span class="built_in">sin</span>\_addr), ntohs(client.sin_port));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associate the newly arrived client socket with completion port</span></span><br><span class="line">    CreateIoCompletionPort((HANDLE)sClient, CompletionPort, (DWORD)sClient, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Launch an asynchronous operation for new arrived connection</span></span><br><span class="line">    lpPerIOData = (LPPER\_IO\_OPERATION_DATA)HeapAlloc(</span><br><span class="line">      GetProcessHeap(),</span><br><span class="line">      HEAP\_ZERO\_MEMORY,</span><br><span class="line">      <span class="keyword">sizeof</span>(PER\_IO\_OPERATION_DATA));</span><br><span class="line">    lpPerIOData-&gt;Buffer.len = MSGSIZE;</span><br><span class="line">    lpPerIOData-&gt;Buffer.buf = lpPerIOData-&gt;szMessage;</span><br><span class="line">    lpPerIOData-&gt;OperationType = RECV_POSTED;</span><br><span class="line">    WSARecv(sClient,</span><br><span class="line">      &amp;lpPerIOData-&gt;Buffer,</span><br><span class="line">      <span class="number">1</span>,</span><br><span class="line">      &amp;lpPerIOData-&gt;NumberOfBytesRecvd,</span><br><span class="line">      &amp;lpPerIOData-&gt;Flags,</span><br><span class="line">      &amp;lpPerIOData-&gt;overlap,</span><br><span class="line">      <span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PostQueuedCompletionStatus(CompletionPort, <span class="number">0xFFFFFFFF</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(CompletionPort);</span><br><span class="line">closesocket(sListen);</span><br><span class="line">WSACleanup();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID CompletionPortID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  HANDLE                  CompletionPort=(HANDLE)CompletionPortID;</span><br><span class="line">  DWORD                   dwBytesTransferred;</span><br><span class="line">  SOCKET                  sClient;</span><br><span class="line">  LPPER\_IO\_OPERATION_DATA lpPerIOData = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (TRUE)</span><br><span class="line">  &#123;</span><br><span class="line">    GetQueuedCompletionStatus(</span><br><span class="line">      CompletionPort,</span><br><span class="line">      &amp;dwBytesTransferred,</span><br><span class="line">      &amp;sClient,</span><br><span class="line">      (LPOVERLAPPED *)&amp;lpPerIOData,</span><br><span class="line">      INFINITE);</span><br><span class="line">    <span class="keyword">if</span> (dwBytesTransferred == <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (lpPerIOData-&gt;OperationType == RECV_POSTED)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (dwBytesTransferred == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Connection was closed by client</span></span><br><span class="line">        closesocket(sClient);</span><br><span class="line">        HeapFree(GetProcessHeap(), <span class="number">0</span>, lpPerIOData);        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        lpPerIOData-&gt;szMessage\[dwBytesTransferred\] = '\\0';</span><br><span class="line">        send(sClient, lpPerIOData-&gt;szMessage, dwBytesTransferred, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Launch another asynchronous operation for sClient</span></span><br><span class="line">        <span class="built_in">memset</span>(lpPerIOData, <span class="number">0</span>, <span class="keyword">sizeof</span>(PER\_IO\_OPERATION_DATA));</span><br><span class="line">        lpPerIOData-&gt;Buffer.len = MSGSIZE;</span><br><span class="line">        lpPerIOData-&gt;Buffer.buf = lpPerIOData-&gt;szMessage;</span><br><span class="line">        lpPerIOData-&gt;OperationType = RECV_POSTED;</span><br><span class="line">        WSARecv(sClient,</span><br><span class="line">          &amp;lpPerIOData-&gt;Buffer,</span><br><span class="line">          <span class="number">1</span>,</span><br><span class="line">          &amp;lpPerIOData-&gt;NumberOfBytesRecvd,</span><br><span class="line">          &amp;lpPerIOData-&gt;Flags,</span><br><span class="line">          &amp;lpPerIOData-&gt;overlap,</span><br><span class="line">          <span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，说说主线程： 1.创建完成端口对象 2.创建工作者线程（这里工作者线程的数量是按照CPU的个数来决定的，这样可以达到最佳性能） 3.创建监听套接字，绑定，监听，然后程序进入循环 4.在循环中，我做了以下几件事情： (1).接受一个客户端连接 (2). 将该客户端套接字与完成端口绑定到一起(还是调用CreateIoCompletionPort，但这次的作用不同)，注意，按道理来讲，此时传递给 CreateIoCompletionPort的第三个参数应该是一个完成键，一般来讲，程序都是传递一个单句柄数据结构的地址，该单句柄数据包含了和该 客户端连接有关的信息，由于我们只关心套接字句柄，所以直接将套接字句柄作为完成键传递； (3).触发一个WSARecv异步调用，这次又用到了“尾随数据”，使接收数据所用的缓冲区紧跟在WSAOVERLAPPED对象之后，此外，还有操作类型等重要信息。 在工作者线程的循环中，我们 1.调用GetQueuedCompletionStatus取得本次I/O的相关信息（例如套接字句柄、传送的字节数、单I/O数据结构的地址等等） 2.通过单I/O数据结构找到接收数据缓冲区，然后将数据原封不动的发送到客户端 3.再次触发一个WSARecv异步操作 六.五种I/O模型的比较 我会从以下几个方面来进行比较 *有无每线程64连接数限制 如 果在选择模型中没有重新定义FD_SETSIZE宏，则每个fd_set默认可以装下64个SOCKET。同样的，受 MAXIMUM_WAIT_OBJECTS宏的影响，事件选择、用事件通知实现的重叠I/O都有每线程最大64连接数限制。如果连接数成千上万，则必须对 客户端套接字进行分组，这样，势必增加程序的复杂度。 相反，异步选择、用完成例程实现的重叠I/O和完成端口不受此限制。 *线程数 除了异步选择以外，其他模型至少需要2个线程。一个主线程和一个辅助线程。同样的，如果连接数大于64，则选择模型、事件选择和用事件通知实现的重叠I/O的线程数还要增加。 *实现的复杂度 我的个人看法是，在实现难度上，异步选择&lt;选择&lt;用完成例程实现的重叠I/O&lt;事件选择&lt;完成端口&lt;用事件通知实现的重叠I/O *性能 由 于选择模型中每次都要重设读集，在select函数返回后还要针对所有套接字进行逐一测试，我的感觉是效率比较差；完成端口和用完成例程实现的重叠I/O 基本上不涉及全局数据，效率应该是最高的，而且在多处理器情形下完成端口还要高一些；事件选择和用事件通知实现的重叠I/O在实现机制上都是采用 WSAWaitForMultipleEvents，感觉效率差不多；至于异步选择，不好比较。所以我的结论是:选择&lt;用事件通知实现的重叠 I/O&lt;事件选择&lt;用完成例程实现的重叠I/O&lt;完成端口 WinSock学习笔记 Socket（套接字） ◆先看定义： typedef unsigned int u_int; typedef u_int SOCKET; ◆Socket相当于进行网络通信两端的插座，只要对方的Socket和自己的Socket有通信联接，双方就可以发送和接收数据了。其定义类似于文件句柄的定义。 ◆Socket有五种不同的类型： 1、流式套接字(stream socket) 定义： #define SOCK_STREAM 1 流式套接字提供了双向、有序的、无重复的以及无记录边界的数据流服务，适合处理大量数据。它是面向联结的，必须建立数据传输链路，同时还必须对传输的数据进行验证，确保数据的准确性。因此，系统开销较大。 2、 数据报套接字(datagram socket) 定义： #define SOCK_DGRAM 2 数据报套接字也支持双向的数据流，但不保证传输数据的准确性，但保留了记录边界。由于数据报套接字是无联接的，例如广播时的联接，所以并不保证接收端是否正在侦听。数据报套接字传输效率比较高。 3、原始套接字(raw-protocol interface) 定义： #define SOCK_RAW 3 原始套接字保存了数据包中的完整IP头，前面两种套接字只能收到用户数据。因此可以通过原始套接字对数据进行分析。 其它两种套接字不常用，这里就不介绍了。 ◆Socket开发所必须需要的文件(以WinSock V2.0为例)： 头文件：Winsock2.h 库文件：WS2_32.LIB 动态库：W32_32.DLL 一些重要的定义 1、数据类型的基本定义：这个大家一看就懂。 typedef unsigned char u_char; typedef unsigned short u_short; typedef unsigned int u_int; typedef unsigned long u_long; 2、 网络地址的数据结构，有一个老的和一个新的的，请大家留意，如果想知道为什么， 请发邮件给Bill Gate。其实就是计算机的IP地址，不过一般不用用点分开的IP地 址，当然也提供一些转换函数。 ◆ 旧的网络地址结构的定义，为一个4字节的联合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> </span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">union</span> </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123;</span> u\_char s\_b1,s\_b2,s\_b3,s\_b4; &#125; S\_un_b;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123;</span> u\_short s\_w1,s\_w2; &#125; S\_un_w;</span><br><span class="line"> u\_long S\_addr;</span><br><span class="line"> &#125; S_un;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> s\_addr S\_un.S_addr <span class="comment">/* can be used for most tcp &amp; ip code */</span></span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>其实完全不用这么麻烦，请看下面: ◆ 新的网络地址结构的定义： 非常简单，就是一个无符号长整数 unsigned long。举个例子：IP地址为127.0.0.1的网络地址是什么呢？请看定义： #define INADDR_LOOPBACK 0x7f000001 3、 套接字地址结构 (1)、sockaddr结构： struct sockaddr { u_short sa_family; /* address family <em>/ char sa_data[14]; /</em> up to 14 bytes of direct address */ }; sa_family 为网络地址类型，一般为AF_INET，表示该socket在Internet域中进行通信，该地址结构随选择的协议的不同而变化，因此一般情况下另一个 与该地址结构大小相同的sockaddr_in结构更为常用，sockaddr_in结构用来标识TCP/IP协议下的地址。换句话说，这个结构是通用 socket地址结构，而下面的sockaddr_in是专门针对Internet域的socket地址结构。 (2)、sockaddr_in结构 struct sockaddr_in { short sin_family; u_short sin_port; struct in_addr sin_addr; char sin_zero[8]; }; sin _family 为网络地址类型，必须设定为AF_INET。sin_port为服务端口，注意不要使用已固定的服务端口，如HTTP的端口80等。如果端口设置为0，则 系统会自动分配一个唯一端口。sin_addr为一个unsigned long的IP地址。sin_zero为填充字段，纯粹用来保证结构的大小。 ◆ 将常用的用点分开的IP地址转换为unsigned long类型的IP地址的函数： unsigned long inet_addr(const char FAR * cp ) 用法： unsigned long addr=inet_addr(“192.1.8.84”) ◆ 如果将sin_addr设置为INADDR_ANY，则表示所有的IP地址，也即所有的计算机。 #define INADDR_ANY (u_long)0x00000000 4、 主机地址： 先看定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line"> <span class="keyword">char</span> FAR * h_name; <span class="comment">/* official name of host */</span></span><br><span class="line"> <span class="keyword">char</span> FAR * FAR * h_aliases; <span class="comment">/* alias list */</span></span><br><span class="line"> short h_addrtype; <span class="comment">/* host address type */</span></span><br><span class="line"> short h_length; <span class="comment">/* length of address */</span></span><br><span class="line"> <span class="keyword">char</span> FAR * FAR * h\_addr\_list; <span class="comment">/* list of addresses */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> h\_addr h\_addr_list\[0\] <span class="comment">/* address, for backward compat */</span></span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>h_name为主机名字。 h_aliases为主机别名列表。 h_addrtype为地址类型。 h_length为地址类型。 h_addr_list为IP地址，如果该主机有多个网卡，就包括地址的列表。 另外还有几个类似的结构，这里就不一一介绍了。 5、 常见TCP/IP协议的定义： #define IPPROTO_IP 0 #define IPPROTO_ICMP 1 #define IPPROTO_IGMP 2 #define IPPROTO_TCP 6 #define IPPROTO_UDP 17 #define IPPROTO_RAW 255 具体是什么协议，大家一看就知道了。 套接字的属性 为了灵活使用套接字，我们可以对它的属性进行设定。 1、 属性内容： //允许调试输出 #define SO_DEBUG 0x0001 /* turn on debugging info recording <em>/ //是否监听模式 #define SO_ACCEPTCONN 0x0002 /</em> socket has had listen() <em>/ //套接字与其他套接字的地址绑定 #define SO_REUSEADDR 0x0004 /</em> allow local address reuse <em>/ //保持连接 #define SO_KEEPALIVE 0x0008 /</em> keep connections alive <em>/ //不要路由出去 #define SO_DONTROUTE 0x0010 /</em> just use interface addresses <em>/ //设置为广播 #define SO_BROADCAST 0x0020 /</em> permit sending of broadcast msgs <em>/ //使用环回不通过硬件 #define SO_USELOOPBACK 0x0040 /</em> bypass hardware when possible <em>/ //当前拖延值 #define SO_LINGER 0x0080 /</em> linger on close if data present <em>/ //是否加入带外数据 #define SO_OOBINLINE 0x0100 /</em> leave received OOB data in line <em>/ //禁用LINGER选项 #define SO_DONTLINGER (int)(~SO_LINGER) //发送缓冲区长度 #define SO_SNDBUF 0x1001 /</em> send buffer size <em>/ //接收缓冲区长度 #define SO_RCVBUF 0x1002 /</em> receive buffer size <em>/ //发送超时时间 #define SO_SNDTIMEO 0x1005 /</em> send timeout <em>/ //接收超时时间 #define SO_RCVTIMEO 0x1006 /</em> receive timeout <em>/ //错误状态 #define SO_ERROR 0x1007 /</em> get error status and clear <em>/ //套接字类型 #define SO_TYPE 0x1008 /</em> get socket type */ 2、 读取socket属性： int getsockopt(SOCKET s, int level, int optname, char FAR * optval, int FAR * optlen) s为欲读取属性的套接字。level为套接字选项的级别，大多数是特定协议和套接字专有的。如IP协议应为 IPPROTO_IP。 optname为读取选项的名称 optval为存放选项值的缓冲区指针。 optlen为缓冲区的长度 用法： int ttl=0; //读取TTL值 int rc = getsockopt( s, IPPROTO_IP, IP_TTL, (char *)&amp;ttl, sizeof(ttl)); //来自MS platform SDK 2003 3、 设置socket属性： int setsockopt(SOCKET s,int level, int optname,const char FAR * optval, int optlen) s为欲设置属性的套接字。 level为套接字选项的级别，用法同上。 optname为设置选项的名称 optval为存放选项值的缓冲区指针。 optlen为缓冲区的长度 用法： int ttl=32; //设置TTL值 int rc = setsockopt( s, IPPROTO_IP, IP_TTL, (char *)&amp;ttl, sizeof(ttl)); 套接字的使用步骤 1、启动Winsock：对Winsock DLL进行初始化，协商Winsock的版本支持并分配必要的 资源。（服务器端和客户端） int WSAStartup( WORD wVersionRequested, LPWSADATA lpWSAData ) wVersionRequested为打算加载Winsock的版本，一般如下设置： wVersionRequested=MAKEWORD(2,0) 或者直接赋值：wVersionRequested=2 LPWSADATA为初始化Socket后加载的版本的信息,定义如下： typedef struct WSAData { WORD wVersion; WORD wHighVersion; char szDescription[WSADESCRIPTION_LEN+1]; char szSystemStatus[WSASYS_STATUS_LEN+1]; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char FAR * lpVendorInfo; } WSADATA, FAR * LPWSADATA; 如果加载成功后数据为： wVersion＝2 表示加载版本为2.0。 wHighVersion＝514 表示当前系统支持socket最高版本为2.2。 szDescription=”WinSock 2.0” szSystemStatus=”Running” 表示正在运行。 iMaxSockets＝0 表示同时打开的socket最大数，为0表示没有限制。 iMaxUdpDg＝0 表示同时打开的数据报最大数，为0表示没有限制。 lpVendorInfo 没有使用，为厂商指定信息预留。 该函数使用方法： WORD wVersion=MAKEWORD(2,0); WSADATA wsData; int nResult= WSAStartup(wVersion,&amp;wsData); if(nResult !=0) { //错误处理 } 2、创建套接字：（服务器端和客户端） SOCKET socket( int af, int type, int protocol ); af为网络地址类型，一般为AF_INET，表示在Internet域中使用。 type为套接字类型，前面已经介绍了。 protocol为指定网络协议，一般为IPPROTO_IP。 用法： SOCKET sock=socket(AF_INET,SOCK_STREAM,IPPROTO_IP); if(sock==INVALID_SOCKET) { //错误处理 } 3、套接字的绑定：将本地地址绑定到所创建的套接字上。（服务器端和客户端） int bind( SOCKET s, const struct sockaddr FAR * name, int namelen ) s为已经创建的套接字。 name为socket地址结构，为sockaddr结构，如前面讨论的，我们一般使用sockaddr_in 结构，在使用再强制转换为sockaddr结构。 namelen为地址结构的长度。 用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr;</span><br><span class="line">addr. <span class="built_in">sin</span>\_family=AF\_INET;</span><br><span class="line">addr. sin_port= htons(<span class="number">0</span>); <span class="comment">//保证字节顺序</span></span><br><span class="line">addr. <span class="built_in">sin</span>\_addr.s\_addr= inet_addr(<span class="string">"192.1.8.84"</span>)</span><br><span class="line"><span class="keyword">int</span> nResult=bind(s,(sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(sockaddr));</span><br><span class="line"><span class="keyword">if</span>(nResult==SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、 套接字的监听：（服务器端） int listen(SOCKET s, int backlog ) s为一个已绑定但未联接的套接字。 backlog为指定正在等待联接的最大队列长度，这个参数非常重要，因为服务器一般可 以提供多个连接。 用法： int nResult=listen(s,5) //最多5个连接 if(nResult==SOCKET_ERROR) { //错误处理 } 5、套接字等待连接:：（服务器端） SOCKET accept( SOCKET s, struct sockaddr FAR * addr, int FAR * addrlen ) s为处于监听模式的套接字。 sockaddr为接收成功后返回客户端的网络地址。 addrlen为网络地址的长度。 用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr;</span><br><span class="line">SOCKET s_d=accept(s,(sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(sockaddr));</span><br><span class="line"><span class="keyword">if</span>(s==INVALID_SOCKET)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6、套接字的连结：将两个套接字连结起来准备通信。（客户端） int connect(SOCKET s, const struct sockaddr FAR * name, int namelen ) s为欲连结的已创建的套接字。 name为欲连结的socket地址。 namelen为socket地址的结构的长度。 用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in addr;</span><br><span class="line">addr. <span class="built_in">sin</span>\_family=AF\_INET;</span><br><span class="line">addr. sin_port=htons(<span class="number">0</span>); <span class="comment">//保证字节顺序</span></span><br><span class="line">addr. <span class="built_in">sin</span>\_addr.s\_addr= htonl(INADDR_ANY) <span class="comment">//保证字节顺序</span></span><br><span class="line"><span class="keyword">int</span> nResult=<span class="built_in">connect</span>(s,(sockaddr*)&amp;addr,<span class="keyword">sizeof</span>(sockaddr));</span><br><span class="line"><span class="keyword">if</span>(nResult==SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、套接字发送数据：（服务器端和客户端） int send(SOCKET s, const char FAR * buf, int len, int flags ) s为服务器端监听的套接字。 buf为欲发送数据缓冲区的指针。 len为发送数据缓冲区的长度。 flags为数据发送标记。 返回值为发送数据的字符数。 ◆这里讲一下这个发送标记，下面8中讨论的接收标记也一样： flag取值必须为0或者如下定义的组合：0表示没有特殊行为。 #define MSG_OOB 0x1 /* process out-of-band data <em>/ #define MSG_PEEK 0x2 /</em> peek at incoming message <em>/ #define MSG_DONTROUTE 0x4 /</em> send without using routing tables */ MSG_OOB表示数据应该带外发送，所谓带外数据就是TCP紧急数据。 MSG_PEEK表示使有用的数据复制到缓冲区内，但并不从系统缓冲区内删除。 MSG_DONTROUTE表示不要将包路由出去。 用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf\[\]=<span class="string">"xiaojin"</span>;</span><br><span class="line"><span class="keyword">int</span> nResult=send(s,buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line"><span class="keyword">if</span>(nResult==SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、 套接字的数据接收：（客户端） int recv( SOCKET s, char FAR * buf, int len, int flags ) s为准备接收数据的套接字。 buf为准备接收数据的缓冲区。 len为准备接收数据缓冲区的大小。 flags为数据接收标记。 返回值为接收的数据的字符数。 用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> mess\[<span class="number">1000</span>\];</span><br><span class="line"><span class="keyword">int</span> nResult =recv(s,mess,<span class="number">1000</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(nResult==SOCKET_ERROR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、中断套接字连接：通知服务器端或客户端停止接收和发送数据。（服务器端和客户端） int shutdown(SOCKET s, int how) s为欲中断连接的套接字。 How为描述禁止哪些操作，取值为：SD_RECEIVE、SD_SEND、SD_BOTH。 #define SD_RECEIVE 0x00 #define SD_SEND 0x01 #define SD_BOTH 0x02 用法： int nResult= shutdown(s,SD_BOTH); if(nResult==SOCKET_ERROR) { //错误处理 } 10、 关闭套接字：释放所占有的资源。（服务器端和客户端） int closesocket( SOCKET s ) s为欲关闭的套接字。 用法： int nResult=closesocket(s); if(nResult==SOCKET_ERROR) { //错误处理 } 与socket有关的一些函数介绍 1、读取当前错误值：每次发生错误时，如果要对具体问题进行处理，那么就应该调用这个函数取得错误代码。 int WSAGetLastError(void ); #define h_errno WSAGetLastError() 错误值请自己阅读Winsock2.h。 2、将主机的unsigned long值转换为网络字节顺序(32位)：为什么要这样做呢？因为不同的计算机使用不同的字节顺序存储数据。因此任何从Winsock函数对IP地址和端口号的引用和传给Winsock函数的IP地址和端口号均时按照网络顺序组织的。 u_long htonl(u_long hostlong); 举例：htonl(0)=0 htonl(80)= 1342177280 3、将unsigned long数从网络字节顺序转换位主机字节顺序，是上面函数的逆函数。 u_long ntohl(u_long netlong); 举例：ntohl(0)=0 ntohl(1342177280)= 80 4、将主机的unsigned short值转换为网络字节顺序(16位)：原因同2： u_short htons(u_short hostshort); 举例：htonl(0)=0 htonl(80)= 20480 5、将unsigned short数从网络字节顺序转换位主机字节顺序，是上面函数的逆函数。 u_short ntohs(u_short netshort); 举例：ntohs(0)=0 ntohsl(20480)= 80 6、将用点分割的IP地址转换位一个in_addr结构的地址，这个结构的定义见笔记(一)，实际上就是一个unsigned long值。计算机内部处理IP地址可是不认识如192.1.8.84之类的数据。 unsigned long inet_addr( const char FAR * cp ); 举例：inet_addr(“192.1.8.84”)=1409810880 inet_addr(“127.0.0.1”)= 16777343 如果发生错误，函数返回INADDR_NONE值。 7、将网络地址转换位用点分割的IP地址，是上面函数的逆函数。 char FAR * inet_ntoa( struct in_addr in ); 举例：char * ipaddr=NULL; char addr[20]; in_addr inaddr; inaddr. s_addr=16777343; ipaddr= inet_ntoa(inaddr); strcpy(addr,ipaddr); &lt;</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章，未经许可，任何单位及个人不得做营利性使用！如有侵权请联系作者。
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2016/01/c++-%E8%99%9A%E5%87%BD%E6%95%B0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            c++-虚函数
          
        </div>
      </a>
    
    
      <a href="/2015/12/c++-%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">c++-实现双向链表</div>
      </a>
    
  </nav>

  
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 翟天野
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.svg" alt="Tianye Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  
  if(document.getElementsByClassName("tocbot").length !== 0){
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      scrollContainer: 'main',
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto'
    });
  }
</script>

<script src="/comm/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/comm/jquery.modal.min.css">
<script src="/comm/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="/comm/photoswipe_dist/photoswipe.css">
<link rel="stylesheet" href="/comm/photoswipe_dist/default-skin/default-skin.css">
<script src="/comm/photoswipe_dist/photoswipe.min.js"></script>
<script src="/comm/photoswipe_dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="/comm/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>