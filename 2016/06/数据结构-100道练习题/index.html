<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="翟天野 天野 翟天野博客" />
   
  <meta name="description" content="The seeker of the world" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    数据结构-100道练习题 |  Tianye Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/comm/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="/comm/pace.min.js"></script>

  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?a65f4359920e6c4b5b2b6d0519751045";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<link rel="alternate" href="/atom.xml" title="Tianye Blog" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-数据结构-100道练习题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据结构-100道练习题
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-100%E9%81%93%E7%BB%83%E4%B9%A0%E9%A2%98/" class="article-date">
  <time datetime="2016-06-10T08:59:09.000Z" itemprop="datePublished">2016-06-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">22.5k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">109 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p>1.把二元查找树转变成排序的双向链表</p>
<p>题目：<br>输入一棵二元查找树，将该二元查找树转换成一个排序的双向链表。<br>要求不能创建任何新的结点，只调整指针的指向。<br>10<br>/ <br>6 14<br>/ \ / <br>4 8 12 16<br>转换成双向链表<br>4=6=8=10=12=14=16。<br>首先我们定义的二元查找树节点的数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nValue; <span class="comment">// value of node</span></span><br><span class="line">BSTreeNode *m_pLeft; <span class="comment">// left child of node</span></span><br><span class="line">BSTreeNode *m_pRight; <span class="comment">// right child of node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ANSWER:</span><br><span class="line">This is a traditional problem that can be solved using recursion.</span><br><span class="line">For each node, connect the double linked lists created from left and right child node to form a full list.</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param root The root node of the tree</span></span><br><span class="line"><span class="comment">* @return The head node of the converted list.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">BSTreeNode * <span class="title">treeToLinkedList</span><span class="params">(BSTreeNode * root)</span> </span>&#123;</span><br><span class="line">BSTreeNode * head, * tail;</span><br><span class="line">helper(head, tail, root);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(BSTreeNode *&amp; head, BSTreeNode *&amp; tail, BSTreeNode *root)</span> </span>&#123;</span><br><span class="line">BSTreeNode *lt, *rh;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">head = <span class="literal">NULL</span>, tail = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">helper(head, lt, root-&gt;m_pLeft);</span><br><span class="line">helper(rh, tail, root-&gt;m_pRight);</span><br><span class="line"><span class="keyword">if</span> (lt!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">lt-&gt;m_pRight = root;</span><br><span class="line">root-&gt;m_pLeft = lt;</span><br><span class="line">&#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">head = root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rh!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">root-&gt;m_pRight=rh;</span><br><span class="line">rh-&gt;m_pLeft = root;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tail = root;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.设计包含min 函数的栈。<br>定义栈的数据结构，要求添加一个min 函数，能够得到栈的最小元素。<br>要求函数min、push 以及pop 的时间复杂度都是O(1)。<br>ANSWER:<br>Stack is a LIFO data structure. When some element is popped from the stack, the status will recover to the original status as before that element was pushed. So we can recover the minimum element, too.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinStackElement</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">MinStackElement * data;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MinStack <span class="title">MinStackInit</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">MinStack <span class="built_in">stack</span>;</span><br><span class="line"><span class="built_in">stack</span>.<span class="built_in">size</span> = maxSize;</span><br><span class="line"><span class="built_in">stack</span>.data = (MinStackElement*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MinStackElement)*maxSize);</span><br><span class="line"><span class="built_in">stack</span>.top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinStackFree</span><span class="params">(MinStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">free</span>(<span class="built_in">stack</span>.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MinStackPush</span><span class="params">(MinStack <span class="built_in">stack</span>, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>.top == <span class="built_in">stack</span>.<span class="built_in">size</span>) error(“out of <span class="built_in">stack</span> space.”);</span><br><span class="line">MinStackElement* p = <span class="built_in">stack</span>.data[<span class="built_in">stack</span>.top];</span><br><span class="line">p-&gt;data = d;</span><br><span class="line">p-&gt;<span class="built_in">min</span> = (<span class="built_in">stack</span>.top==<span class="number">0</span>?d : <span class="built_in">stack</span>.data[top<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;<span class="built_in">min</span> &gt; d) p-&gt;<span class="built_in">min</span> = d;</span><br><span class="line">top ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinStackPop</span><span class="params">(MinStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>.top == <span class="number">0</span>) error(“<span class="built_in">stack</span> is empty!”);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>.data[–<span class="built_in">stack</span>.top].data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MinStackMin</span><span class="params">(MinStack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>.top == <span class="number">0</span>) error(“<span class="built_in">stack</span> is empty!”);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">stack</span>.data[<span class="built_in">stack</span>.top<span class="number">-1</span>].<span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.求子数组的最大和<br>题目：<br>输入一个整形数组，数组里有正数也有负数。<br>数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。<br>求所有子数组的和的最大值。要求时间复杂度为O(n)。<br>例如输入的数组为1, -2, 3, 10, -4, 7, 2, -5，和最大的子数组为3, 10, -4, 7, 2，<br>因此输出为该子数组的和18。<br>ANSWER:<br>A traditional greedy approach.<br>Keep current sum, slide from left to right, when sum &lt; 0, reset sum to 0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubarray</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">size</span>&lt;=<span class="number">0</span>) error(“error <span class="built_in">array</span> <span class="built_in">size</span>”);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = – (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cur &lt; <span class="built_in">size</span>) &#123;</span><br><span class="line">sum += a[cur++];</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line"><span class="built_in">max</span> = sum;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.在二元树中找出和为某一值的所有路径<br>题目：输入一个整数和一棵二元树。<br>从树的根结点开始往下访问一直到叶结点所经过的所有结点形成一条路径。<br>打印出和与输入整数相等的所有路径。<br>例如输入整数22 和如下二元树<br>10<br>/ <br>5 12<br>/ <br>4 7<br>则打印出两条路径：10, 12 和10, 5, 7。<br>二元树节点的数据结构定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> // <span class="title">a</span> <span class="title">node</span> <span class="title">in</span> <span class="title">the</span> <span class="title">binary</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nValue; <span class="comment">// value of node</span></span><br><span class="line">BinaryTreeNode *m_pLeft; <span class="comment">// left child of node</span></span><br><span class="line">BinaryTreeNode *m_pRight; <span class="comment">// right child of node</span></span><br><span class="line">&#125;;</span><br><span class="line">ANSWER:</span><br><span class="line">Use backtracking <span class="keyword">and</span> recurison. We need a <span class="built_in">stack</span> to help backtracking the path.</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">TreeNode * left;</span><br><span class="line">TreeNode * right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPaths</span><span class="params">(TreeNode * root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> path[MAX_HEIGHT];</span><br><span class="line">helper(root, sum, path, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode * root, <span class="keyword">int</span> sum, <span class="keyword">int</span> path[], <span class="keyword">int</span> top)</span> </span>&#123;</span><br><span class="line">path[top++] = root.data;</span><br><span class="line">sum -= root.data;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum == <span class="number">0</span>) printPath(path, top);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) helper(root-&gt;left, sum, path, top);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right!=<span class="literal">NULL</span>) helper(root-&gt;right, sum, path, top);</span><br><span class="line">&#125;</span><br><span class="line">top –;</span><br><span class="line">sum += root.data;    <span class="comment">//….</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>5.查找最小的k 个元素<br>题目：输入n 个整数，输出其中最小的k 个。<br>例如输入1，2，3，4，5，6，7 和8 这8 个数字，则最小的4 个数字为1，2，3 和4。<br>ANSWER:<br>This is a very traditional question…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">O(nlogn): cat I_FILE | sort -n | head -n K</span><br><span class="line">O(kn): <span class="keyword">do</span> insertion sort until k elements are retrieved.</span><br><span class="line">O(n+klogn): Take O(n) time to bottom-up build a min-heap. Then sift-down k-1 times.</span><br><span class="line">So traditional that I don’t want to <span class="built_in">write</span> the codes…</span><br><span class="line">Only gives the siftup <span class="keyword">and</span> siftdown function.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@param i the index of the element in heap a[<span class="number">0</span>…n<span class="number">-1</span>] to be sifted up</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftup</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> j=(i&amp;<span class="number">1</span>==<span class="number">0</span> ? i<span class="number">-1</span> : i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> p=(i<span class="number">-1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (j&lt;n &amp;&amp; a[j]&lt;a[i]) i = j;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; a[p]) swap(a, i, p);</span><br><span class="line">i = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftdown</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">2</span>*i+<span class="number">1</span>&lt;n)&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l+<span class="number">1</span>&lt;n &amp;&amp; a[l+<span class="number">1</span>] &lt; a[l]) l++;</span><br><span class="line"><span class="keyword">if</span> (a[l] &lt; a[i]) swap(a, i, l);</span><br><span class="line">i=l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6 题<br>腾讯面试题：<br>给你10 分钟时间，根据上排给出十个数，在其下排填出对应的十个数<br>要求下排每个数都是先前上排那十个数在下排出现的次数。<br>上排的十个数如下：<br>【0，1，2，3，4，5，6，7，8，9】<br>举一个例子，<br>数值: 0,1,2,3,4,5,6,7,8,9<br>分配: 6,2,1,0,0,0,1,0,0,0<br>0 在下排出现了6 次，1 在下排出现了2 次，<br>2 在下排出现了1 次，3 在下排出现了0 次….<br>以此类推..<br>ANSWER:<br>I don’t like brain teasers. Will skip most of them…</p>
<p>第7 题<br>微软亚院之编程判断俩个链表是否相交<br>给出俩个单向链表的头指针，比如h1，h2，判断这俩个链表是否相交。<br>为了简化问题，我们假设俩个链表均不带环。<br>问题扩展：<br>1.如果链表可能有环列?<br>2.如果需要求出俩个链表相交的第一个节点列?<br>ANSWER:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// if there is no cycle.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isJoinedSimple</span><span class="params">(Node * h1, Node * h2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (h1-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">h1 = h1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (h2-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">h2 = h2-&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> h1 == h2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if there could exist cycle</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isJoined</span><span class="params">(Node *h1, Node * h2)</span> </span>&#123;</span><br><span class="line">Node* cylic1 = testCylic(h1);</span><br><span class="line">Node* cylic2 = testCylic(h2);</span><br><span class="line"><span class="keyword">if</span> (cylic1+cylic2==<span class="number">0</span>) <span class="keyword">return</span> isJoinedSimple(h1, h2);</span><br><span class="line"><span class="keyword">if</span> (cylic1==<span class="number">0</span> &amp;&amp; cylic2!=<span class="number">0</span> || cylic1!=<span class="number">0</span> &amp;&amp;cylic2==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">Node *p = cylic1;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p==cylic2 || p-&gt;next == cylic2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">p=p-&gt;next-&gt;next;</span><br><span class="line">cylic1 = cylic1-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p==cylic1) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">testCylic</span><span class="params">(Node * h1)</span> </span>&#123;</span><br><span class="line">Node * p1 = h1, *p2 = h1;</span><br><span class="line"><span class="keyword">while</span> (p2!=<span class="literal">NULL</span> &amp;&amp; p2-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">p1 = p1-&gt;next;</span><br><span class="line">p2 = p2-&gt;next-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第8 题<br>此贴选一些比较怪的题，，由于其中题目本身与算法关系不大，仅考考思维。特此并作一题。<br>1.有两个房间，一间房里有三盏灯，另一间房有控制着三盏灯的三个开关，<br>这两个房间是分割开的，从一间里不能看到另一间的情况。<br>现在要求受训者分别进这两房间一次，然后判断出这三盏灯分别是由哪个开关控制的。<br>有什么办法呢？<br>ANSWER:<br>Skip.</p>
<p>2.你让一些人为你工作了七天，你要用一根金条作为报酬。金条被分成七小块，每天给出一<br>块。<br>如果你只能将金条切割两次，你怎样分给这些工人?<br>ANSWER:<br>1+2+4;</p>
<ol start="3">
<li>★用一种算法来颠倒一个链接表的顺序。现在在不用递归式的情况下做一遍。<br>ANSWER:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">reverse</span><span class="params">(Node * head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">Node * ph = reverse(head-&gt;next);</span><br><span class="line">head-&gt;next-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> ph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node * <span class="title">reverseNonrecurisve</span><span class="params">(Node * head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">Node * p = head;</span><br><span class="line">Node * previous = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">p-&gt;next = previous;</span><br><span class="line">previous = p;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = previous;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★用一种算法在一个循环的链接表里插入一个节点，但不得穿越链接表。<br>ANSWER:<br>I don’t understand what is “Chuanyue”.<br>★用一种算法整理一个数组。你为什么选择这种方法?<br>ANSWER:<br>What is “Zhengli?”<br>★用一种算法使通用字符串相匹配。<br>ANSWER:<br>What is “Tongyongzifuchuan”… a string with “*” and “?”? If so, here is the code.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">char</span> * ptn)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*ptn == ‘\<span class="number">0</span>’) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (*ptn == ‘*’) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (match(str++, ptn+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (*str != ‘\<span class="number">0</span>’);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*str == ‘\<span class="number">0</span>’) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (*str == *ptn || *ptn == ‘?’) &#123;</span><br><span class="line"><span class="keyword">return</span> match(str+<span class="number">1</span>, ptn+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★颠倒一个字符串。优化速度。优化空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">reverseFixlen(str, <span class="built_in">strlen</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseFixlen</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p = str+n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (str &lt; p) &#123;</span><br><span class="line"><span class="keyword">char</span> c = *str;</span><br><span class="line">*str = *p; *p=c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>★颠倒一个句子中的词的顺序，比如将“我叫克丽丝”转换为“克丽丝叫我”，<br>实现速度最快，移动最少。<br>ANSWER:<br>Reverse the whole string, then reverse each word. Using the reverseFixlen() above.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseWordsInSentence</span><span class="params">(<span class="keyword">char</span> * sen)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(sen);</span><br><span class="line">reverseFixlen(sen, len);</span><br><span class="line"><span class="keyword">char</span> * p = str;</span><br><span class="line"><span class="keyword">while</span> (*p!=’\<span class="number">0</span>’) &#123;</span><br><span class="line"><span class="keyword">while</span> (*p == ‘ ‘ &amp;&amp; *p!=’\<span class="number">0</span>’) p++;</span><br><span class="line">str = p;</span><br><span class="line"><span class="keyword">while</span> (p!= ‘ ‘ &amp;&amp; *p!=’\<span class="number">0</span>’) p++;</span><br><span class="line">reverseFixlen(str, p-str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★找到一个子字符串。优化速度。优化空间。<br>ANSWER:<br>KMP? BM? Sunday? Using BM or sunday, if it’s ASCII string, then it’s easy to fast access the auxiliary array. Otherwise an hashmap or bst may be needed. Lets assume it’s an ASCII string.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bm_strstr</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">char</span> *sub)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(sub);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> aux[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">memset</span>(aux, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">256</span>, len+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">aux[sub[i]] = len – i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line">i=len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;n) &#123;</span><br><span class="line"><span class="keyword">int</span> j=i, k=len<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (k&gt;=<span class="number">0</span> &amp;&amp; str[j–] == sub[k–])</span><br><span class="line">;</span><br><span class="line"><span class="keyword">if</span> (k&lt;<span class="number">0</span>) <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i+<span class="number">1</span>&lt;n)</span><br><span class="line">i+=aux[str[i+<span class="number">1</span>]];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">However, this algorithm, as well as BM, KMP algorithms use O(|sub|) space. If this is not acceptable, Rabin-carp algorithm can do it. Using hashing to fast filter out most false matchings.</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Hbase 127</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rc_strstr</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">char</span> * sub)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dest= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> * p = sub;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> TO_REDUCE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (*p!=’\<span class="number">0</span>’) &#123;</span><br><span class="line">dest = HBASE * dest + (<span class="keyword">int</span>)(*p);</span><br><span class="line">TO_REDUCE *= HBASE;</span><br><span class="line">len ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line">p = str;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*p != ‘\<span class="number">0</span>’) &#123;</span><br><span class="line"><span class="keyword">if</span> (i++&lt;len) hash = HBASE * dest + (<span class="keyword">int</span>)(*p);</span><br><span class="line"><span class="keyword">else</span> hash = (hash – (TO_REDUCE * (<span class="keyword">int</span>)(*(p-len))))*HBASE + (<span class="keyword">int</span>)(*p);</span><br><span class="line"><span class="keyword">if</span> (hash == dest &amp;&amp; i&gt;=len &amp;&amp; <span class="built_in">strncmp</span>(sub, p-len+<span class="number">1</span>, len) == <span class="number">0</span>) <span class="keyword">return</span> i-len;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★比较两个字符串，用O(n)时间和恒量空间。<br>ANSWER:<br>What is “comparing two strings”? Just normal string comparison? The natural way use O(n) time and O(1) space.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">char</span> * p1, <span class="keyword">char</span> * p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*p1 != ‘\<span class="number">0</span>’ &amp;&amp; *p2 != ‘\<span class="number">0</span>’ &amp;&amp; *p1 == *p2) &#123;</span><br><span class="line">p1++, p2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*p1 == ‘\<span class="number">0</span>’ &amp;&amp; *p2 == ‘\<span class="number">0</span>’) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (*p1 == ‘\<span class="number">0</span>’) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (*p2 == ‘\<span class="number">0</span>’) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (*p1 – *p2); <span class="comment">// it can be negotiated whether the above 3 if’s are necessary, I don’t like to omit them.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>★假设你有一个用1001 个整数组成的数组，这些整数是任意排列的，但是你知道所有的整数都在1 到1000(包括1000)之间。此外，除一个数字出现两次外，其他所有数字只出现一次。假设你只能对这个数组做一次处理，用一种算法找出重复的那个数字。如果你在运算中使用了辅助的存储方式，那么你能找到不用这种方式的算法吗?<br>ANSWER:<br>Sum up all the numbers, then subtract the sum from 1001*1002/2.<br>Another way, use A XOR A XOR B = B:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findX</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">k ~= a[i]~i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>★不用乘法或加法增加8 倍。现在用同样的方法增加7 倍。<br>ANSWER:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n&lt;&lt;3;</span><br><span class="line">(n&lt;&lt;3)-n;</span><br></pre></td></tr></table></figure>

<p>第9 题<br>判断整数序列是不是二元查找树的后序遍历结果<br>题目：输入一个整数数组，判断该数组是不是某二元查找树的后序遍历的结果。<br>如果是返回true，否则返回false。<br>例如输入5、7、6、9、11、10、8，由于这一整数序列是如下树的后序遍历结果：<br>8<br>/ <br>6 10<br>/ \ / <br>5 7 9 11<br>因此返回true。<br>如果输入7、4、6、5，没有哪棵树的后序遍历的结果是这个序列，因此返回false。<br>ANSWER:<br>This is an interesting one. There is a traditional question that requires the binary tree to be re-constructed from mid/post/pre order results. This seems similar. For the problems related to (binary) trees, recursion is the first choice.<br>In this problem, we know in post-order results, the last number should be the root. So we have known the root of the BST is 8 in the example. So we can split the array by the root.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPostorderResult</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (e==s) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i=e<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (a[e]&gt;a[i] &amp;&amp; i&gt;=s) i–;</span><br><span class="line"><span class="keyword">if</span> (!helper(a, i+<span class="number">1</span>, e<span class="number">-1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> k = l;</span><br><span class="line"><span class="keyword">while</span> (a[e]&lt;a[i] &amp;&amp; i&gt;=s) i–;</span><br><span class="line"><span class="keyword">return</span> helper(a, s, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第10 题<br>翻转句子中单词的顺序。<br>题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。<br>句子中单词以空格符隔开。为简单起见，标点符号和普通字母一样处理。<br>例如输入“I am a student.”，则输出“student. a am I”。<br>Answer:<br>Already done this. Skipped.</p>
<p>第11 题<br>求二叉树中节点的最大距离…<br>如果我们把二叉树看成一个图，父子节点之间的连线看成是双向的，<br>我们姑且定义”距离”为两节点之间边的个数。<br>写一个程序，<br>求一棵二叉树中相距最远的两个节点之间的距离。<br>ANSWER:<br>This is interesting… Also recursively, the longest distance between two nodes must be either from root to one leaf, or between two leafs. For the former case, it’s the tree height. For the latter case, it should be the sum of the heights of left and right subtrees of the two leaves’ most least ancestor.<br>The first case is also the sum the heights of subtrees, just the height + 0.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> depth;</span><br><span class="line"><span class="keyword">return</span> helper(root, depth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(Node * root, <span class="keyword">int</span> &amp;depth)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">depth = <span class="number">0</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ld, rd;</span><br><span class="line"><span class="keyword">int</span> maxleft = helper(root-&gt;left, ld);</span><br><span class="line"><span class="keyword">int</span> maxright = helper(root-&gt;right, rd);</span><br><span class="line">depth = <span class="built_in">max</span>(ld, rd)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(maxleft, <span class="built_in">max</span>(maxright, ld+rd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第12 题<br>题目：求1+2+…+n，<br>要求不能使用乘除法、for、while、if、else、switch、case 等关键字以及条件判断语句<br>（A?B:C）。<br>ANSWER:<br>1+..+n=n*(n+1)/2=(n^2+n)/2<br>it is easy to get x/2, so the problem is to get n^2<br>though no if/else is allowed, we can easilly Go around using short-pass.<br>using macro to make it fancier:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  T(X, Y, i) (Y &amp; (1&lt;&lt;i)) &amp;&amp; X+=(Y&lt;&lt;i)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> r=n;</span><br><span class="line">T(r, n, <span class="number">0</span>); T(r, n,<span class="number">1</span>); T(r, n, <span class="number">2</span>); … T(r, n, <span class="number">31</span>);</span><br><span class="line"><span class="keyword">return</span> r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第13 题：<br>题目：输入一个单向链表，输出该链表中倒数第k 个结点。链表的倒数第0 个结点为链表的尾指针。<br>链表结点定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nKey;</span><br><span class="line">ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br><span class="line">Answer:</span><br><span class="line">Two ways. <span class="number">1</span>: record the length of the linked <span class="built_in">list</span>, then go n-k steps. <span class="number">2</span>: use two cursors.</span><br><span class="line">Time complexities are exactly the same.</span><br><span class="line"><span class="function">Node * <span class="title">lastK</span><span class="params">(Node * head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k&lt;<span class="number">0</span>) error(“k &lt; <span class="number">0</span>”);</span><br><span class="line">Node *p=head, *pk=head;</span><br><span class="line"><span class="keyword">for</span> (;k&gt;<span class="number">0</span>;k–) &#123;</span><br><span class="line"><span class="keyword">if</span> (pk-&gt;next!=<span class="literal">NULL</span>) pk = pk-&gt;next;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (pk-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">p=p-&gt;next, pk=pk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第14 题：<br>题目：输入一个已经按升序排序过的数组和一个数字，<br>在数组中查找两个数，使得它们的和正好是输入的那个数字。<br>要求时间复杂度是O(n)。如果有多对数字的和等于输入的数字，输出任意一对即可。<br>例如输入数组1、2、4、7、11、15 和数字15。由于4+11=15，因此输出4 和11。<br>ANSWER:<br>Use two cursors. One at front and the other at the end. Keep track of the sum by moving the cursors.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find2Number</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *f = a, *e=a+n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> sum = *f + *e;</span><br><span class="line"><span class="keyword">while</span> (sum != dest &amp;&amp; f &lt; e) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; dest) sum = *(++f);</span><br><span class="line"><span class="keyword">else</span> sum = *(–e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum == dest) <span class="built_in">printf</span>(“%d, %d\n”, *f, *e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>第15 题：<br>题目：输入一颗二元查找树，将该树转换为它的镜像，<br>即在转换后的二元查找树中，左子树的结点都大于右子树的结点。<br>用递归和循环两种方法完成树的镜像转换。<br>例如输入：<br>8<br>/ <br>6 10<br>/\ /<br>5 7 9 11<br>输出：<br>8<br>/ <br>10 6<br>/\ /<br>11 9 7 5<br>定义二元查找树的结点为：<br>struct BSTreeNode // a node in the binary search tree (BST)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> m_nValue; <span class="comment">// value of node</span></span><br><span class="line">BSTreeNode *m_pLeft; <span class="comment">// left child of node</span></span><br><span class="line">BSTreeNode *m_pRight; <span class="comment">// right child of node</span></span><br><span class="line">&#125;;</span><br><span class="line">ANSWER:</span><br><span class="line">This is the basic application of recursion.</span><br><span class="line">PS: I don’t like the m_xx naming convension.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node ** l, Node ** r)</span> </span>&#123;</span><br><span class="line">Node * p = *l;</span><br><span class="line">*l = *r;</span><br><span class="line">*r = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mirror</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">swap(&amp;(root-&gt;left), &amp;(root-&gt;right));</span><br><span class="line">mirror(root-&gt;left);</span><br><span class="line">mirror(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mirrorIteratively</span><span class="params">(Node * root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;Node*&gt; buf;</span><br><span class="line">buf.push(root);</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">Node * n = <span class="built_in">stack</span>.pop();</span><br><span class="line">swap(&amp;(root-&gt;left), &amp;(root-&gt;right));</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) buf.push(root-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) buf.push(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第16 题：<br>题目（微软）：<br>输入一颗二元树，从上往下按层打印树的每个结点，同一层中按照从左往右的顺序打印。<br>例如输入<br>8<br>/ <br>6 10<br>/ \ / <br>5 7 9 11<br>输出8 6 10 5 7 9 11。<br>ANSWER:<br>The nodes in the levels are printed in the similar manner their parents were printed. So it should be an FIFO queue to hold the level. I really don’t remember the function name of the stl queue, so I will write it in Java…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printByLevel</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">Node sentinel = <span class="keyword">new</span> Node();</span><br><span class="line">LinkedList&lt;Node&gt; q=<span class="keyword">new</span> LinkedList&lt;Node&gt;();</span><br><span class="line">q.addFirst(root); q.addFirst(sentinel);</span><br><span class="line"><span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">Node n = q.removeLast();</span><br><span class="line"><span class="keyword">if</span> (n==sentinel) &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(“\n”);</span><br><span class="line">q.addFirst(sentinel);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(n);</span><br><span class="line"><span class="keyword">if</span> (n.left() != null) q.addFirst(n.left());</span><br><span class="line"><span class="keyword">if</span> (n.right()!=null) q.addFirst(n.right());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第17 题：<br>题目：在一个字符串中找到第一个只出现一次的字符。如输入abaccdeff，则输出b。<br>分析：这道题是2006 年google 的一道笔试题。<br>ANSWER:<br>Again, this depends on what is “char”. Let’s assume it as ASCII.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstSingle</span><span class="params">(<span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">255</span>];</span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">255</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">char</span> *p=str;</span><br><span class="line"><span class="keyword">while</span> (*p!=’\<span class="number">0</span>’) &#123;</span><br><span class="line">a[*p] ++;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line">p = str;</span><br><span class="line"><span class="keyword">while</span> (*p!=’\<span class="number">0</span>’) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[*p] == <span class="number">1</span>) <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ‘\<span class="number">0</span>’; <span class="comment">// this must the one that occurs exact 1 time.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第18 题：<br>题目：n 个数字（0,1,…,n-1）形成一个圆圈，从数字0 开始，<br>每次从这个圆圈中删除第m 个数字（第一个为当前数字本身，第二个为当前数字的下一个数<br>字）。<br>当一个数字删除后，从被删除数字的下一个继续删除第m 个数字。<br>求出在这个圆圈中剩下的最后一个数字。<br>July：我想，这个题目，不少人已经见识过了。<br>ANSWER:<br>Actually, although this is a so traditional problem, I was always to lazy to think about this or even to search for the answer.(What a shame…). Finally, by google I found the elegant solution for it.<br>The keys are:</p>
<p>1) if we shift the ids by k, namely, start from k instead of 0, we should add the result by k%n<br>2) after the first round, we start from k+1 ( possibly % n) with n-1 elements, that is equal to an (n-1) problem while start from (k+1)th element instead of 0, so the answer is (f(n-1, m)+k+1)%n<br>3) k = m-1, so f(n,m)=(f(n-1,m)+m)%n.<br>finally, f(1, m) = 0;<br>Now this is a O(n) solution.<br>int joseph(int n, int m) {<br>int fn=0;<br>for (int i=2; i&lt;=n; i++) {<br>fn = (fn+m)%i;  }<br>return fn;<br>}</p>
<p>第19 题：<br>题目：定义Fibonacci 数列如下：<br>/ 0 n=0<br>f(n)= 1 n=1<br>\ f(n-1)+f(n-2) n=2<br>输入n，用最快的方法求该数列的第n 项。<br>分析：在很多C 语言教科书中讲到递归函数的时候，都会用Fibonacci 作为例子。<br>因此很多程序员对这道题的递归解法非常熟悉，但….呵呵，你知道的。。<br>ANSWER:<br>This is the traditional problem of application of mathematics…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let A=</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">1</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">0</span>&#125;</span><br><span class="line">f(n) = A^(n<span class="number">-1</span>)[<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">this</span> gives a O(<span class="built_in">log</span> n) solution.</span><br><span class="line"><span class="keyword">int</span> f(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> result[<span class="number">4</span>];</span><br><span class="line">power(A, n, result);</span><br><span class="line"><span class="keyword">return</span> result[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span> _r)</span> </span>&#123;</span><br><span class="line">_r[<span class="number">0</span>] = A[<span class="number">0</span>]*B[<span class="number">0</span>] + A[<span class="number">1</span>]*B[<span class="number">2</span>];</span><br><span class="line">_r[<span class="number">1</span>] = A[<span class="number">0</span>]*B[<span class="number">1</span>] + A[<span class="number">1</span>]*B[<span class="number">3</span>];</span><br><span class="line">_r[<span class="number">2</span>] = A[<span class="number">2</span>]*B[<span class="number">0</span>] + A[<span class="number">3</span>]*B[<span class="number">2</span>];</span><br><span class="line">_r[<span class="number">3</span>] = A[<span class="number">2</span>]*B[<span class="number">1</span>] + A[<span class="number">3</span>]*B[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n, <span class="keyword">int</span> _r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">1</span>) &#123; <span class="built_in">memcpy</span>(A, _r, <span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">4</span>];</span><br><span class="line">power(A, n&gt;&gt;<span class="number">1</span>, _r);</span><br><span class="line">multiply(_r, _r, tmp);</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">multiply(tmp, A, _r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(_r, tmp, <span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第20 题：<br>题目：输入一个表示整数的字符串，把该字符串转换成整数并输出。<br>例如输入字符串”345″，则输出整数345。<br>ANSWER:<br>This question checks how the interviewee is familiar with C/C++? I’m so bad at C/C++…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> neg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> * p = str;</span><br><span class="line"><span class="keyword">if</span> (*p == ‘-’) &#123;</span><br><span class="line">p++; neg = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == ‘+’) &#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*p != ‘\<span class="number">0</span>’) &#123;</span><br><span class="line"><span class="keyword">if</span> (*p&gt;=’<span class="number">0</span>′ &amp;&amp; *p &lt;= ‘<span class="number">9</span>’) &#123;</span><br><span class="line">num = num * <span class="number">10</span> + (*p-’<span class="number">0</span>’);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">error(“illegal number”);</span><br><span class="line">&#125;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第21 题<br>2010 年中兴面试题<br>编程求解：<br>输入两个整数n 和m，从数列1，2，3…….n 中随意取几个数,<br>使其和等于m ,要求将其中所有的可能组合列出来.<br>ANSWER<br>This is a combination generation problem.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findCombination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&gt;m) findCombination(m, m);</span><br><span class="line"><span class="keyword">int</span> aux[n];</span><br><span class="line"><span class="built_in">memset</span>(aux, <span class="number">0</span>, n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">helper(m, <span class="number">0</span>, aux);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> dest, <span class="keyword">int</span> idx, <span class="keyword">int</span> aux[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dest == <span class="number">0</span>)</span><br><span class="line">dump(aux, n);</span><br><span class="line"><span class="keyword">if</span> (dest &lt;= <span class="number">0</span> || idx==n) <span class="keyword">return</span>;</span><br><span class="line">helper(dest, idx+<span class="number">1</span>, aux, n);</span><br><span class="line">aux[idx] = <span class="number">1</span>;</span><br><span class="line">helper(dest-idx<span class="number">-1</span>, idx+<span class="number">1</span>, aux, n);</span><br><span class="line">aux[idx] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="keyword">int</span> aux[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line"><span class="keyword">if</span> (aux[i]) <span class="built_in">printf</span>(“%<span class="number">3</span>d”, i+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(“\n”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第22 题：<br>有4 张红色的牌和4 张蓝色的牌，主持人先拿任意两张，再分别在A、B、C 三人额头上贴任意两张牌，A、B、C 三人都可以看见其余两人额头上的牌，看完后让他们猜自己额头上是什么颜色的牌，A 说不知道，B 说不知道，C 说不知道，然后A 说知道了。<br>请教如何推理，A 是怎么知道的。如果用程序，又怎么实现呢？<br>ANSWER<br>I dont’ like brain teaser. As an AI problem, it seems impossible to write the solution in 20 min…</p>
<p>It seems that a brute-force edge cutting strategy could do. Enumerate all possibilities, then for each guy delete the permutation that could be reduced if failed (for A, B, C at 1st round), Then there should be only one or one group of choices left.</p>
<p>But who uses this as an interview question?</p>
<p>第23 题：<br>用最简单，最快速的方法计算出下面这个圆形是否和正方形相交。”<br>3D 坐标系原点(0.0,0.0,0.0)<br>圆形:<br>半径r = 3.0<br>圆心o = (<em>.</em>, 0.0, <em>.</em>)<br>正方形:<br>4 个角坐标;<br>1:(<em>.</em>, 0.0, <em>.</em>)<br>2:(<em>.</em>, 0.0, <em>.</em>)<br>3:(<em>.</em>, 0.0, <em>.</em>)<br>4:(<em>.</em>, 0.0, <em>.</em>)<br>ANSWER<br>Crap… I totally cannot understand this problem… Does the <em>.</em> represent any possible number?</p>
<p>第24 题：<br>链表操作，<br>（1）.单链表就地逆置，<br>（2）合并链表<br>ANSWER<br>Reversing a linked list. Already done.</p>
<p>What do you mean by merge? Are the original lists sorted and need to be kept sorted? If not, are there any special requirements?<br>I will only do the sorted merging.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">merge</span><span class="params">(Node * h1, Node * h2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (h1 == <span class="literal">NULL</span>) <span class="keyword">return</span> h2;</span><br><span class="line"><span class="keyword">if</span> (h2 == <span class="literal">NULL</span>) <span class="keyword">return</span> h1;</span><br><span class="line">Node * head;</span><br><span class="line"><span class="keyword">if</span> (h1-&gt;data&gt;h2-&gt;data) &#123;</span><br><span class="line">head = h2; h2=h2-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">head = h1; h1=h1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node * current = head;</span><br><span class="line"><span class="keyword">while</span> (h1 != <span class="literal">NULL</span> &amp;&amp; h2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (h1 == <span class="literal">NULL</span> || (h2!=<span class="literal">NULL</span> &amp;&amp; h1-&gt;data&gt;h2-&gt;data)) &#123;</span><br><span class="line">current-&gt;next = h2; h2=h2-&gt;next; current = current-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">current-&gt;next = h1; h1=h1-&gt;next; current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第25 题：<br>写一个函数,它的原形是int continumax(char *outputstr,char *intputstr)<br>功能：<br>在字符串中找出连续最长的数字串，并把这个串的长度返回，<br>并把这个最长数字串付给其中一个函数参数outputstr 所指内存。<br>例如：”abcd12345ed125ss123456789″的首地址传给intputstr 后，函数将返回9，<br>outputstr 所指的值为123456789<br>ANSWER:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">continumax</span><span class="params">(<span class="keyword">char</span> *outputstr, <span class="keyword">char</span> *inputstr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> * pstart = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (*inputstr &gt;= ‘<span class="number">0</span>’ &amp;&amp; *inputstr &lt;=’<span class="number">9</span>’) &#123;</span><br><span class="line">len ++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="built_in">max</span>) pstart = inputstr-len;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*inputstr++==’\<span class="number">0</span>’) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)</span><br><span class="line">*outputstr++ = pstart++;</span><br><span class="line">*outputstr = ‘\<span class="number">0</span>’;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>26.左旋转字符串<br>题目：<br>定义字符串的左旋转操作：把字符串前面的若干个字符移动到字符串的尾部。<br>如把字符串abcdef 左旋转2 位得到字符串cdefab。请实现字符串左旋转的函数。<br>要求时间对长度为n 的字符串操作的复杂度为O(n)，辅助内存为O(1)。<br>ANSWER<br>Have done it. Using reverse word function above.</p>
<p>27.跳台阶问题<br>题目：一个台阶总共有n 级，如果一次可以跳1 级，也可以跳2 级。<br>求总共有多少总跳法，并分析算法的时间复杂度。<br>这道题最近经常出现，包括MicroStrategy 等比较重视算法的公司<br>都曾先后选用过个这道题作为面试题或者笔试题。<br>ANSWER<br>f(n)=f(n-1)+f(n-2), f(1)=1, f(2)=2, let f(0) = 1, then f(n) = fibo(n-1);</p>
<p>28.整数的二进制表示中1 的个数<br>题目：输入一个整数，求该整数的二进制表达中有多少个1。<br>例如输入10，由于其二进制表示为1010，有两个1，因此输出2。<br>分析：<br>这是一道很基本的考查位运算的面试题。<br>包括微软在内的很多公司都曾采用过这道题。<br>ANSWER<br>Traditional question. Use the equation xxxxxx10000 &amp; (xxxxxx10000-1) = xxxxxx00000<br>Note: for negative numbers, this also hold, even with 100000000 where the “-1” leading to an underflow.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">n=n &amp; (n<span class="number">-1</span>);</span><br><span class="line">c++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">another solution is to lookup table. O(k), <span class="function">k is <span class="title">sizeof</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123; c++; n = n &amp; (<span class="number">1</span>&lt;&lt;(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">8</span><span class="number">-1</span>)); &#125;</span><br><span class="line"><span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">c+=tab[n&amp;<span class="number">0xff</span>];</span><br><span class="line">n &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>29.栈的push、pop 序列<br>题目：输入两个整数序列。其中一个序列表示栈的push 顺序，<br>判断另一个序列有没有可能是对应的pop 顺序。<br>为了简单起见，我们假设push 序列的任意两个整数都是不相等的。<br>比如输入的push 序列是1、2、3、4、5，那么4、5、3、2、1 就有可能是一个pop 系列。<br>因为可以有如下的push 和pop 序列：<br>push 1，push 2，push 3，push 4，pop，push 5，pop，pop，pop，pop，<br>这样得到的pop 序列就是4、5、3、2、1。<br>但序列4、3、5、1、2 就不可能是push 序列1、2、3、4、5 的pop 序列。<br>ANSWER<br>This seems interesting. However, a quite straightforward and promising way is to actually build the stack and check whether the pop action can be achieved.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPopSeries</span><span class="params">(<span class="keyword">int</span> push[], <span class="keyword">int</span> pop[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; helper;</span><br><span class="line"><span class="keyword">int</span> i1=<span class="number">0</span>, i2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i2 &lt; n) &#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">stack</span>.empty() || <span class="built_in">stack</span>.<span class="built_in">peek</span>() != pop[i2]) &#123;</span><br><span class="line"><span class="keyword">if</span> (i1&lt;n)</span><br><span class="line"><span class="built_in">stack</span>.push(push[i1++]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.<span class="built_in">peek</span>() == pop[i2]) &#123;</span><br><span class="line"><span class="built_in">stack</span>.pop(); i2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30.在从1 到n 的正数中1 出现的次数<br>题目：输入一个整数n，求从1 到n 这n 个整数的十进制表示中1 出现的次数。<br>例如输入12，从1 到12 这些整数中包含1 的数字有1，10，11 和12，1 一共出现了5 次。<br>分析：这是一道广为流传的google 面试题。<br>ANSWER<br>This is complicated… I hate it…<br>Suppose we have N=ABCDEFG.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> G&lt;<span class="number">1</span>, <span class="meta"># of 1’s in the units digits is ABCDEF, <span class="meta-keyword">else</span> ABCDEF+1</span></span><br><span class="line"><span class="keyword">if</span> F&lt;<span class="number">1</span>, <span class="meta"># of 1’s in the digit of tens is (ABCDE)*10, <span class="meta-keyword">else</span> <span class="meta-keyword">if</span> F==1: (ABCDE)*10+G+1, <span class="meta-keyword">else</span> (ABCDE+1)*10</span></span><br><span class="line"><span class="keyword">if</span> E&lt;<span class="number">1</span>, <span class="meta"># of 1’s in 3rd digit is (ABCD)*100, <span class="meta-keyword">else</span> <span class="meta-keyword">if</span> E==1: (ABCD)*100+FG+1, <span class="meta-keyword">else</span> (ABCD+1)*100</span></span><br><span class="line">… so on.</span><br><span class="line"><span class="keyword">if</span> A=<span class="number">1</span>, # of <span class="number">1</span> in <span class="keyword">this</span> digit is BCDEFG+<span class="number">1</span>, <span class="keyword">else</span> it’s <span class="number">1</span>*<span class="number">1000000</span>;</span><br><span class="line">so to fast access the digits <span class="keyword">and</span> helper numbers, we need to build the fast access table of prefixes <span class="keyword">and</span> suffixes.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOf1s</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> prefix[<span class="number">10</span>], suffix[<span class="number">10</span>], digits[<span class="number">10</span>]; <span class="comment">//10 is enough for 32bit integers</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (base &lt; n) &#123;</span><br><span class="line">suffix[i] = n % base;</span><br><span class="line">digit[i] = (n % (base * <span class="number">10</span>)) – suffix[i];</span><br><span class="line">prefix[i] = (n – suffix[i] – digit[i]*base)/<span class="number">10</span>;</span><br><span class="line">i++, base*=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">base = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (digit[j] &lt; <span class="number">1</span>) count += prefix;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (digit[j]==<span class="number">1</span>) count += prefix + suffix + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> count += prefix+base;</span><br><span class="line">base *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>31.华为面试题：<br>一类似于蜂窝的结构的图，进行搜索最短路径（要求5 分钟）<br>ANSWER<br>Not clear problem. Skipped. Seems a Dijkstra could do.</p>
<p>int dij</p>
<p>32.<br>有两个序列a,b，大小都为n,序列元素的值任意整数，无序；<br>要求：通过交换a,b 中的元素，使[序列a 元素的和]与[序列b 元素的和]之间的差最小。<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a&#x3D;[100,99,98,1,2, 3];</span><br><span class="line">var b&#x3D;[1, 2, 3, 4,5,40];</span><br></pre></td></tr></table></figure>
<p>ANSWER<br>If only one swap can be taken, it is a O(n^2) searching problem, which can be reduced to O(nlogn) by sorting the arrays and doing binary search.<br>If any times of swaps can be performed, this is a double combinatorial problem.<br>In the book &lt;<beauty of codes>&gt;, a similar problem splits an array to halves as even as possible. It is possible to take binary search, when SUM of the array is not too high. Else this is a quite time consuming brute force problem. I cannot figure out a reasonable solution.</p>
<p>33.<br>实现一个挺高级的字符匹配算法：<br>给一串很长字符串，要求找到符合要求的字符串，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如目的串：123 1******3***2 ,12*****3 这些都要找出来</span><br></pre></td></tr></table></figure>
<p>其实就是类似一些和谐系统。。。。。<br>ANSWER<br>Not a clear problem. Seems a bitset can do.</p>
<p>34.<br>实现一个队列。<br>队列的应用场景为：<br>一个生产者线程将int 类型的数入列，一个消费者线程将int 类型的数出列<br>ANSWER<br>I don’t know multithread programming at all….</p>
<p>35.<br>求一个矩阵中最大的二维矩阵(元素和最大).如:<br>1 2 0 3 4<br>2 3 4 5 1<br>1 1 5 3 0<br>中最大的是:<br>4 5<br>5 3<br>要求:(1)写出算法;(2)分析时间复杂度;(3)用C 写出关键代码<br>ANSWER</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">This is the traditional problem in Programming Pearls. However, the best result is too complicated to achieve. So lets do the suboptimal one. O(n^3) solution.</span><br><span class="line">1) We have know that the similar problem for 1 dim array can be done in O(n) time. However, this cannot be done in both directions in the same time. We can only calculate the accumulations for all the sublist from i to j, (0&lt;&#x3D;i&lt;&#x3D;j&lt;n) for each array in one dimension, which takes O(n^2) time. Then in the other dimension, do the tradtional greedy search.</span><br><span class="line">3) To achieve O(n^2) for accumulation for each column, accumulate 0 to i (i&#x3D;0,n-1) first, then calcuate the result by acc(i, j) &#x3D; acc(0, j)-acc(0,i-1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;acc[i*n+j] &#x3D;&gt; acc(i,j)</span><br><span class="line">void accumulate(int a[], int n, int acc[]) &#123;</span><br><span class="line">int i&#x3D;0;</span><br><span class="line">acc[i] &#x3D; a[i];</span><br><span class="line">for (i&#x3D;1;i&lt;n; i++) &#123;</span><br><span class="line">acc[i] &#x3D; acc[i-1]+a[i];</span><br><span class="line">&#125;</span><br><span class="line">for (i&#x3D;1; i&lt;n; i++) &#123;</span><br><span class="line">for (j&#x3D;i; j&lt;n; j++) &#123;</span><br><span class="line">acc[i*n+j] &#x3D; acc[j] – acc[i-1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第36 题-40 题（有些题目搜集于CSDN 上的网友，已标明）：<br>36.引用自网友：longzuo<br>谷歌笔试：<br>n 支队伍比赛，分别编号为0，1，2。。。。n-1，已知它们之间的实力对比关系，<br>存储在一个二维数组w[n][n]中，w[i][j] 的值代表编号为i，j 的队伍中更强的一支。<br>所以w[i][j]=i 或者j，现在给出它们的出场顺序，并存储在数组order[n]中，<br>比如order[n] = {4,3,5,8,1……}，那么第一轮比赛就是4 对3， 5 对8。…….<br>胜者晋级，败者淘汰，同一轮淘汰的所有队伍排名不再细分，即可以随便排，<br>下一轮由上一轮的胜者按照顺序，再依次两两比，比如可能是4 对5,直至出现第一名<br>编程实现，给出二维数组w，一维数组order 和用于输出比赛名次的数组result[n]，<br>求出result。<br>ANSWER<br>This question is like no-copying merge, or in place matrix rotation.</p>
<ul>
<li>No-copying merge: merge order to result, then merge the first half from order, and so on.</li>
<li>in place matrix rotation: rotate 01, 23, .. , 2k/2k+1 to 02…2k, 1,3,…2k+1…<br>The two approaches are both complicated. However, notice one special feature that the losers’ order doesn’t matter. Thus a half-way merge is much simpler and easier:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">knockOut</span><span class="params">(<span class="keyword">int</span> **w, <span class="keyword">int</span> order[], <span class="keyword">int</span> result[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> round = n;</span><br><span class="line"><span class="built_in">memcpy</span>(result, order, n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">while</span> (round&gt;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>,j=<span class="number">0</span>; i&lt;round; i+=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> win= (i==round<span class="number">-1</span>) ? i : w[i][i+<span class="number">1</span>];</span><br><span class="line">swap(result, j, win);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>37.<br>有n 个长为m+1 的字符串，<br>如果某个字符串的最后m 个字符与某个字符串的前m 个字符匹配，则两个字符串可以联接，<br>问这n 个字符串最多可以连成一个多长的字符串，如果出现循环，则返回错误。<br>ANSWER<br>This is identical to the problem to find the longest acylic path in a directed graph. If there is a cycle, return false.<br>Firstly, build the graph. Then search the graph for the longest path.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_NUM 201</span></span><br><span class="line"><span class="keyword">int</span> inDegree[MAX_NUM];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestConcat</span><span class="params">(<span class="keyword">char</span> ** strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> graph[MAX_NUM][MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> prefixHash[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> suffixHash[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">calcHash(strs[i], prefixHash[i], suffixHash[i]);</span><br><span class="line">graph[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(inDegree, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (suffixHash[i]==prefixHash[j] &amp;&amp; <span class="built_in">strncmp</span>(strs[i]+<span class="number">1</span>, strs[j], m) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (i==j) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// there is a self loop, return false.</span></span><br><span class="line">graph[i][<span class="number">0</span>] ++;</span><br><span class="line">graph[i][graph[i*n]] = j;</span><br><span class="line">inDegree[j] ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> longestPath(graph, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 1. do topological sort, record index[i] in topological order.</span></span><br><span class="line"><span class="comment">* 2. for all 0-in-degree vertexes, set all path length to -1, do relaxation in topological order to find single source shortest path.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> visit[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> parent[MAX_NUM];</span><br><span class="line"><span class="comment">// -1 path weight, so 0 is enough.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_PATH 0</span></span><br><span class="line"><span class="keyword">int</span> d[MAX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPath</span><span class="params">(<span class="keyword">int</span> graph[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(visit, <span class="number">0</span>, n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span> (topSort(graph) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//topological sort failed, there is cycle.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (inDegree[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">memset</span>(parent, <span class="number">-1</span>, n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(d, MAX_PATH, n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;=graph[top[j]][<span class="number">0</span>]; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[top[j]] – <span class="number">1</span> &lt; d[graph[top[j]][k]]) &#123; <span class="comment">// relax with path weight -1</span></span><br><span class="line">d[graph[top[j]][k]] = d[top[j]] – <span class="number">1</span>;</span><br><span class="line">parent[graph[top[j]][k]] = top[j];</span><br><span class="line"><span class="keyword">if</span> (d[graph[top[j]][k]] &lt; <span class="built_in">min</span>) <span class="built_in">min</span> = d[graph[top[j]][k]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="built_in">min</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> top[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> finished[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topSort</span><span class="params">(<span class="keyword">int</span> graph[])</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(visit, <span class="number">0</span>, n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(finished, <span class="number">0</span>, n*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (topdfs(graph, i) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">topdfs</span><span class="params">(<span class="keyword">int</span> graph[], <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[s] != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=graph[s][<span class="number">0</span>]; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited[graph[s][i]]!=<span class="number">0</span> &amp;&amp; finished[graph[s][i]]==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//gray node, a back edge;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (visited[graph[s][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">visited[graph[s][i]] = <span class="number">1</span>;</span><br><span class="line">dfs(graph, graph[s][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">finished[s] = <span class="number">1</span>;</span><br><span class="line">top[cnt++] = s;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity analysis:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hash calculation: O(nm)</span><br><span class="line">Graph construction: O(n*n)</span><br><span class="line">Toplogical sort: as dfs, O(V+E)</span><br><span class="line">All source longest path: O(kE), k is 0-in-degree vetexes number, E is edge number.</span><br><span class="line">As a total, it’s a O(n*n+n*m) solution.</span><br><span class="line">A very good problem. But I really doubt it as a solve-in-20-min interview question.</span><br></pre></td></tr></table></figure>
<p>38.<br>百度面试：<br>1.用天平（只能比较，不能称重）从一堆小球中找出其中唯一一个较轻的，使用x 次天平，<br>最多可以从y 个小球中找出较轻的那个，求y 与x 的关系式。<br>ANSWER:<br>x=1, y=3: if a=b, c is the lighter, else the lighter is the lighter…<br>do this recursively. so y=3^x;</p>
<p>2.有一个很大很大的输入流，大到没有存储器可以将其存储下来，<br>而且只输入一次，如何从这个输入流中随机取得m 个记录。<br>ANSWER</p>
<p>That is, keep total number count N. If N&lt;=m, just keep it.<br>For N&gt;m, generate a random number R=rand(N) in [0, N), replace a[R] with new number if R falls in [0, m).</p>
<p>3.大量的URL 字符串，如何从中去除重复的，优化时间空间复杂度<br>ANSWER</p>
<ol>
<li>Use hash map if there is enough memory.</li>
<li>If there is no enough memory, use hash to put urls to bins, and do it until we can fit the bin into memory.</li>
</ol>
<p>39.<br>网易有道笔试：<br>(1).<br>求一个二叉树中任意两个节点间的最大距离，<br>两个节点的距离的定义是这两个节点间边的个数，<br>比如某个孩子节点和父节点间的距离是1，和相邻兄弟节点间的距离是2，优化时间空间复<br>杂度。<br>ANSWER<br>Have done this.<br>(2).<br>求一个有向连通图的割点，割点的定义是，如果除去此节点和与其相关的边，<br>有向图不再连通，描述算法。<br>ANSWER<br>Do dfs, record low[i] as the lowest vertex that can be reached from i and i’s successor nodes. For each edge i, if low[i] = i and i is not a leaf in dfs tree, then i is a cut point. The other case is the root of dfs, if root has two or more children ,it is a cut point.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* g is defined as: g[i][] is the out edges, g[i][0] is the edge count, g[i][1…g[i][0]] are the other end points.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> visited[MAX_NUM];</span><br><span class="line"><span class="keyword">int</span> lowest[MAX_NUM];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCutPoints</span><span class="params">(<span class="keyword">int</span> *g[], <span class="keyword">int</span> cuts[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(cuts, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"><span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"><span class="built_in">memset</span>(lowest, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">visited[i] = ++cnt;</span><br><span class="line">dfs(g, cuts, n, i, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> *g[], <span class="keyword">int</span> cuts[], <span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> low = visit[s];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=g[s][<span class="number">0</span>]; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (visited[g[s][i]] == <span class="number">0</span>) &#123;</span><br><span class="line">out++;</span><br><span class="line">visited[g[s][i]] = ++cnt;</span><br><span class="line"><span class="keyword">int</span> clow = dfs(g, cuts, n, g[s][i], root);</span><br><span class="line"><span class="keyword">if</span> (clow &lt; low) low = clow;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (low &gt; visit[g[s][i]]) &#123;</span><br><span class="line">low = visit[g[s][i]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lowest[s] = low;</span><br><span class="line"><span class="keyword">if</span> (s == root &amp;&amp; out &gt; <span class="number">1</span>) &#123;</span><br><span class="line">cuts[s] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>40.百度研发笔试题<br>引用自：zp155334877<br>1)设计一个栈结构，满足一下条件：min，push，pop 操作的时间复杂度为O(1)。<br>ANSWER<br>Have done this.</p>
<p>2)一串首尾相连的珠子(m 个)，有N 种颜色(N&lt;=10)，<br>设计一个算法，取出其中一段，要求包含所有N 中颜色，并使长度最短。<br>并分析时间复杂度与空间复杂度。<br>ANSWER<br>Use a sliding window and a counting array, plus a counter which monitors the num of zero slots in counting array. When there is still zero slot(s), advance the window head, until there is no zero slot. Then shrink the window until a slot comes zero. Then one candidate segment of (window_size + 1) is achieved. Repeat this. It is O(n) algorithm since each item is swallowed and left behind only once, and either operation is in constant time.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestFullcolor</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c[m], ctr = m;</span><br><span class="line"><span class="keyword">int</span> h=<span class="number">0</span>, t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span>=n;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (ctr &gt; <span class="number">0</span> &amp;&amp; h&lt;n) &#123;</span><br><span class="line"><span class="keyword">if</span> (c[a[h]] == <span class="number">0</span>) ctr –;</span><br><span class="line">c[a[h]] ++;</span><br><span class="line">h++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (h&gt;=n) <span class="keyword">return</span> <span class="built_in">min</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">c[a[t]] –;</span><br><span class="line"><span class="keyword">if</span> (c[a[t]] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">t++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">min</span> &gt; h-t) <span class="built_in">min</span> = h-t;</span><br><span class="line">t++; ctr++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3)设计一个系统处理词语搭配问题，比如说中国和人民可以搭配，<br>则中国人民人民中国都有效。要求：<br>系统每秒的查询数量可能上千次；<br>词语的数量级为10W；<br>每个词至多可以与1W 个词搭配<br>当用户输入中国人民的时候，要求返回与这个搭配词组相关的信息。<br>ANSWER</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">This problem can be solved in three steps:</span><br><span class="line">1. identify the words</span><br><span class="line">2. recognize the phrase</span><br><span class="line">3. retrieve the information</span><br><span class="line">Solution of 1: The most trivial way to efficiently identify the words is hash table or BST. A balanced BST with 100 words is about 17 levels high. Considering that 100k is not a big number, hashing is enough.</span><br><span class="line">Solution of 2: Since the phrase in this problem consists of only 2 words, it is easy to split the words. There won’t be a lot of candidates. To find a legal combination, we need the “matching” information. So for each word, we need some data structure to tell whether a word can co-occur with it. 100k is a bad number — cannot fit into a 16bit digit. However, 10k*100k is not too big, so we can simply use array of sorted array to do this. 1G integers, or 4G bytes is not a big number, We can also use something like VInt to save a lot of space. To find an index in a 10k sorted array, 14 comparisons are enough.</span><br><span class="line">Above operation can be done in any reasonable work-station’s memory very fast, which should be the result of execution of about a few thousands of simple statements.</span><br><span class="line">Solution of 3: The information could be to big to fit in the memory. So a B-tree may be adopted to index the contents. Caching techniques is also helpful. Considering there are at most 10^9 entries, a 3 or 4 level of B-tree is okay, so it will be at most 5 disk access. However, there are thousands of requests and we can only do hundreds of disk seeking per second. It could be necessary to dispatch the information to several workstations.</span><br></pre></td></tr></table></figure>

<p>41.求固晶机的晶元查找程序<br>晶元盘由数目不详的大小一样的晶元组成，晶元并不一定全布满晶元盘，<br>照相机每次这能匹配一个晶元，如匹配过，则拾取该晶元，<br>若匹配不过，照相机则按测好的晶元间距移到下一个位置。<br>求遍历晶元盘的算法求思路。<br>ANSWER<br>Dont understand.</p>
<p>42.请修改append 函数，利用这个函数实现：<br>两个非降序链表的并集，1-&gt;2-&gt;3 和2-&gt;3-&gt;5 并为1-&gt;2-&gt;3-&gt;5<br>另外只能输出结果，不能修改两个链表的数据。<br>ANSWER<br>I don’t quite understand what it means by “not modifying linked list’s data”. If some nodes will be given up, it is weird for this requirement.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">head</span><span class="params">(Node *h1, Node * h2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (h1==<span class="literal">NULL</span>) <span class="keyword">return</span> h2;</span><br><span class="line"><span class="keyword">if</span> (h2==<span class="literal">NULL</span>) <span class="keyword">return</span> h1;</span><br><span class="line">Node * head;</span><br><span class="line"><span class="keyword">if</span> (h1-&gt;data &lt; h2-&gt;data) &#123;</span><br><span class="line">head =h1; h1=h1-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">head = h2; h2=h2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node * p = head;</span><br><span class="line"><span class="keyword">while</span> (h1!=<span class="literal">NULL</span> || h2!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">Node * candi;</span><br><span class="line"><span class="keyword">if</span> (h1!=<span class="literal">NULL</span> &amp;&amp; h2 != <span class="literal">NULL</span> &amp;&amp; h1-&gt;data &lt; h2-&gt;data || h2==<span class="literal">NULL</span>) &#123;</span><br><span class="line">candi = h1; h1=h1-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">candi = h2; h2=h2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (candi-&gt;data == p-&gt;data) <span class="keyword">delete</span>(candi);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p-&gt;next = candi; p=candi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>43.递归和非递归俩种方法实现二叉树的前序遍历。<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderRecursive</span><span class="params">(TreeNode * node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">visit(node);</span><br><span class="line">preorderRecursive(node-&gt;left);</span><br><span class="line">preorderRecursive(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">For non-recursive traversals, a <span class="built_in">stack</span> must be adopted to replace the implicit program <span class="built_in">stack</span> in recursive programs.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderNonrecursive</span><span class="params">(TreeNode * node)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">s.push(node);</span><br><span class="line"><span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">TreeNode * n = s.pop();</span><br><span class="line">visit(n);</span><br><span class="line"><span class="keyword">if</span> (n-&gt;right!=<span class="literal">NULL</span>) s.push(n-&gt;right);</span><br><span class="line"><span class="keyword">if</span> (n-&gt;left!=<span class="literal">NULL</span>) s.push(n-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderNonrecursive</span><span class="params">(TreeNode * node)</span> </span>&#123;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line">TreeNode * current = node;</span><br><span class="line"><span class="keyword">while</span> (!s.empty() || current != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">s.push(current);</span><br><span class="line">current = current-&gt;left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">current = s.pop();</span><br><span class="line">visit(current);</span><br><span class="line">current = current-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Postorder nonrecursive traversal is the hardest one. However, a simple observation helps that the node first traversed is the node last visited. This recalls the feature of <span class="built_in">stack</span>. So we could use a <span class="built_in">stack</span> to store all the nodes then pop them out altogether.</span><br><span class="line">This is a very elegant solution, while takes O(n) space.</span><br><span class="line">Other very smart methods also work, but <span class="keyword">this</span> is the one I like the most.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderNonrecursive</span><span class="params">(TreeNode * node)</span> </span>&#123;</span><br><span class="line"><span class="comment">// visiting occurs only when current has no right child or last visited is his right child</span></span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; sTraverse, sVisit;</span><br><span class="line">sTraverse.push(node);</span><br><span class="line"><span class="keyword">while</span> (!sTraverse.empty()) &#123;</span><br><span class="line">TreeNode * p = sTraverse.pop();</span><br><span class="line">sVisit.push(p);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>) sTraverse.push(p-&gt;left);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>) sTraverse.push(p-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!sVisit.empty()) &#123;</span><br><span class="line">visit(sVisit.pop);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>44.腾讯面试题：<br>1.设计一个魔方（六面）的程序。<br>ANSWER<br>This is a problem to test OOP.<br>The object MagicCube must have following features</p>
<p>1) holds current status<br>2) easily doing transform<br>3) judge whether the final status is achieved<br>4) to test, it can be initialized<br>5) output current status</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MagicCube</span> &#123;</span></span><br><span class="line"><span class="comment">// 6 faces, 9 chips each face</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span> chips[<span class="number">54</span>];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> X = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> Z = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(<span class="keyword">int</span> direction, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> direction: &#123;</span><br><span class="line">X : &#123; transformX(level); <span class="keyword">break</span>; &#125;</span><br><span class="line">Y : &#123; transformY(level); <span class="keyword">break</span>; &#125;</span><br><span class="line">Z : &#123; transformZ(level); <span class="keyword">break</span>; &#125;</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(“what direction?”);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transformX</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// really tired of making this…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.有一千万条短信，有重复，以文本文件的形式保存，一行一条，有重复。<br>请用5 分钟时间，找出重复出现最多的前10 条。<br>ANSWER<br>10M msgs, each at most 140 chars, that’s 1.4G, which can fit to memory.<br>So use hash map to accumulate occurrence counts.<br>Then use a heap to pick maximum 10.</p>
<p>3.收藏了1 万条url，现在给你一条url，如何找出相似的url。（面试官不解释何为相似）<br>ANSWER<br>What a SB interviewer… The company name should be claimed and if I met such a interviewer, I will contest to HR. The purpose of interview is to see the ability of communication. This is kind of single side shutdown of information exchange.<br>My first answer will be doing edit distance to the url and every candidate. Then it depends on what interviewer will React. Other options includes: fingerprints, tries…</p>
<p>45.雅虎：<br>1.对于一个整数矩阵，存在一种运算，对矩阵中任意元素加一时，需要其相邻（上下左右）<br>某一个元素也加一，现给出一正数矩阵，判断其是否能够由一个全零矩阵经过上述运算得到。<br>ANSWER<br>A assignment problem. Two ways to solve. 1: duplicate each cell to as many as its value, do Hungarian algorithm. Denote the sum of the matrix as M, the edge number is 2M, so the complexity is 2<em>M</em>M; 2: standard maximum flow. If the size of matrix is NxN, then the algorithm using Ford Fulkerson algorithm is M<em>N</em>N.<br>too complex… I will do this when I have time…</p>
<p>2.一个整数数组，长度为n，将其分为m 份，使各份的和相等，求m 的最大值<br>比如{3，2，4，3，6} 可以分成{3，2，4，3，6} m=1;<br>{3,6}{2,4,3} m=2<br>{3,3}{2,4}{6} m=3 所以m 的最大值为3<br>ANSWER<br>Two restrictions on m, 1) 1 &lt;= m &lt;= n; 2) Sum(array) mod m = 0<br>NOTE: no hint that a[i]&gt;0, so m could be larger than sum/max;<br>So firstly prepare the candidates, then do a brute force search on possible m’s.<br>In the search , a DP is available, since if f(array, m) = OR_i( f(array-subset(i), m) ), where Sum(subset(i)) = m.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxShares</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i, m;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) sum += a[i];</span><br><span class="line"><span class="keyword">for</span> (m=n; m&gt;=<span class="number">2</span>; m–) &#123;</span><br><span class="line"><span class="keyword">if</span> (sum mod m != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> aux[n]; <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) aux[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (testShares(a, n, m, sum, sum/m, aux, sum/m, <span class="number">1</span>)) <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testShares</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> sum, <span class="keyword">int</span> groupsum, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> goal, <span class="keyword">int</span> groupId)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (goal == <span class="number">0</span>) &#123;</span><br><span class="line">groupId++;</span><br><span class="line"><span class="keyword">if</span> (groupId == m+<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (aux[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">aux[i] = groupId;</span><br><span class="line"><span class="keyword">if</span> (testShares(a, n, m, sum, groupsum, aux, goal-a[i], groupId)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">aux[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Please do edge cutting yourself, I’m quite enough of this…</p>
<p>46.搜狐：<br>四对括号可以有多少种匹配排列方式？比如两对括号可以有两种：（）（）和（（））<br>ANSWER:<br>Suppose k parenthesis has f(k) permutations, k is large enough. Check the first parenthesis, if there are i parenthesis in it then, the number of permutations inside it and out of it are f(i) and f(k-i-1), respectively. That is</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(k) &#x3D; Sum_i&#x3D;[0,k-1]_(f(i)*f(k-i-1));</span><br><span class="line">which leads to the k’th Catalan number.</span><br></pre></td></tr></table></figure>
<p>47.创新工场：<br>求一个数组的最长递减子序列比如{9，4，3，2，5，4，3，2}的最长递减子序列为{9，5，<br>4，3，2}<br>ANSWER:<br>Scan from left to right, maintain a decreasing sequence. For each number, binary search in the decreasing sequence to see whether it can be substituted.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] findDecreasing(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line"><span class="keyword">int</span>[] ds = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">Arrays.<span class="built_in">fill</span>(ds, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> dsl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lastdsl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</span><br><span class="line"><span class="comment">// binary search in ds to find the first element ds[j] smaller than a[i]. set ds[j] = a[i], or append a[i] at the end of ds</span></span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>, t=dsl<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (s&lt;=t) &#123;</span><br><span class="line"><span class="keyword">int</span> m = s+(t-s)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (ds[m] &lt; a[i]) &#123;</span><br><span class="line">t = m – <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// now s must be at the first ds[j]&lt;a[i], or at the end of ds[]</span></span><br><span class="line">ds[s] = a[i];</span><br><span class="line"><span class="keyword">if</span> (s &gt; dsl) &#123; dsl = s; lastdsl = i; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// now trace back.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=lastdsl<span class="number">-1</span>, j=dsl<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i–) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] == ds[j]) &#123; j –; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; ds[j]) &#123; ds[j–] = a[i]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Arrays.copyOfRange(ds, <span class="number">0</span>, dsl+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>48.微软：<br>一个数组是由一个递减数列左移若干位形成的，比如{4，3，2，1，6，5}<br>是由{6，5，4，3，2，1}左移两位形成的，在这种数组中查找某一个数。<br>ANSWER:<br>The key is that, from the middle point of the array, half of the array is sorted, and the other half is a half-size shifted sorted array. So this can also be done recursively like a binary search.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shiftedBinarySearch</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(a, k, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s&gt;t) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> m = s + (t-s)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[m] == k) <span class="keyword">return</span> m;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[s] &gt;= k &amp;&amp; k &gt; a[m]) <span class="keyword">return</span> helper(a, k, s, m<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> helper(a, k, m+<span class="number">1</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>49.一道看上去很吓人的算法面试题：<br>如何对n 个数进行排序，要求时间复杂度O(n)，空间复杂度O(1)<br>ANSWER:<br>So a comparison sort is not allowed. Counting sort’s space complexity is O(n).<br>More ideas must be exchanged to find more conditions, else this is a crap.</p>
<p>50.网易有道笔试：<br>1.求一个二叉树中任意两个节点间的最大距离，两个节点的距离的定义是这两个节点间边<br>的个数，<br>比如某个孩子节点和父节点间的距离是1，和相邻兄弟节点间的距离是2，优化时间空间复<br>杂度。<br>ANSWER:<br>Have done this before.</p>
<p>2.求一个有向连通图的割点，割点的定义是，<br>如果除去此节点和与其相关的边，有向图不再连通，描述算法。<br>ANSWER:<br>Have done this before.<br>——————————————————————-<br>51.和为n 连续正数序列。<br>题目：输入一个正数n，输出所有和为n 连续正数序列。<br>例如输入15，由于1+2+3+4+5=4+5+6=7+8=15，所以输出3 个连续序列1-5、4-6 和7-8。<br>分析：这是网易的一道面试题。<br>ANSWER:<br>It seems that this can be solved by factorization. However, factorization of large n is impractical!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Suppose n=i+(i+<span class="number">1</span>)+…+(j<span class="number">-1</span>)+j, then n = (i+j)(j-i+<span class="number">1</span>)/<span class="number">2</span> = (j*j – i*i + i + j)/<span class="number">2</span></span><br><span class="line">=&gt; j^<span class="number">2</span> + j + (i-i^<span class="number">2</span><span class="number">-2</span>n) = <span class="number">0</span> =&gt; j=<span class="built_in">sqrt</span>(i^<span class="number">2</span>-i+<span class="number">1</span>/<span class="number">4</span>+<span class="number">2</span>n) – <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">We know  <span class="number">1</span> &lt;= i &lt; j &lt;= n/<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">So <span class="keyword">for</span> each i in [<span class="number">1</span>, n/<span class="number">2</span>], <span class="keyword">do</span> <span class="keyword">this</span> arithmetic to check <span class="keyword">if</span> there is a integer answer.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> findConsecutiveSequence(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n/<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sqroot = calcSqrt(<span class="number">4</span>*i*i+<span class="number">8</span>*n<span class="number">-4</span>*i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (sqroot == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((sqroot &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(i+”-” + ((sqroot<span class="number">-1</span>)/<span class="number">2</span>));</span><br><span class="line">count ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">Use binary search to calculate <span class="built_in">sqrt</span>, <span class="keyword">or</span> just use math functions.</span><br></pre></td></tr></table></figure>
<p>52.二元树的深度。<br>题目：输入一棵二元树的根结点，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为<br>树的深度。</p>
<p>例如：输入二元树：<br>10<br>/ <br>6 14<br>/ / <br>4 12 16<br>输出该树的深度3。<br>二元树的结点定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SBinaryTreeNode</span> // <span class="title">a</span> <span class="title">node</span> <span class="title">of</span> <span class="title">the</span> <span class="title">binary</span> <span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nValue; <span class="comment">// value of node</span></span><br><span class="line">SBinaryTreeNode *m_pLeft; <span class="comment">// left child of node</span></span><br><span class="line">SBinaryTreeNode *m_pRight; <span class="comment">// right child of node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分析：这道题本质上还是考查二元树的遍历。</p>
<p>ANSWER:<br>Have done this.</p>
<p>53.字符串的排列。<br>题目：输入一个字符串，打印出该字符串中字符的所有排列。<br>例如输入字符串abc，则输出由字符a、b、c 所能排列出来的所有字符串<br>abc、acb、bac、bca、cab 和cba。<br>分析：这是一道很好的考查对递归理解的编程题，<br>因此在过去一年中频繁出现在各大公司的面试、笔试题中。<br>ANSWER:<br>Full permutation generation. I will use another technique that swap two neighboring characters each time. It seems that all the characters are different. I need to think about how to do it when duplications is allowed. Maybe simple recursion is better for that.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generatePermutation</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n&gt;<span class="number">20</span>) &#123; error(“are you crazy?”); &#125;</span><br><span class="line"><span class="keyword">byte</span> d[n];</span><br><span class="line"><span class="keyword">int</span> pos[n], dpos[n];  <span class="comment">// pos[i], the position of i’th number, dpos[i] the number in s[i] is the dpos[i]’th smallest</span></span><br><span class="line">qsort(s);  <span class="comment">// I cannot remember the form of qsort in C…</span></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">byte</span>)*n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) pos[i]=i, dpos[i]=i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">while</span> (r = findFirstAvailable(s, d, pos, n)) &#123;</span><br><span class="line"><span class="keyword">if</span> (r== <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">swap(s, pos, dpos, d, r, r+d[r]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;dpos[r]; i–)</span><br><span class="line">d[i] = -d[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirstAvailable</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">byte</span> d[], <span class="keyword">int</span> pos[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;<span class="number">1</span>; i–) &#123;</span><br><span class="line"><span class="keyword">if</span> (s[pos[i]] &gt; s[pos[i]+d[pos[i]]]) <span class="keyword">return</span> pos[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aswap(ARR, X, Y) &#123;int t=ARR[X]; ARR[X]=ARR[y]; ARR[Y]=t;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> pos[], <span class="keyword">int</span> dpos[], <span class="keyword">byte</span> d[], <span class="keyword">int</span> r, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">aswap(s, r, s);</span><br><span class="line">aswap(d, r, s);</span><br><span class="line">aswap(pos, dpos[r], dpos[s]);</span><br><span class="line">aswap(dpos, r, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe full of bugs. Please refer to algorithm manual <span class="keyword">for</span> explansion.</span><br><span class="line">Pros: Amotized O(1) time for each move. Only two characters change position for each move.</span><br><span class="line">Cons: as you can see, very complicated. Extra space needed.</span><br></pre></td></tr></table></figure>
<p>54.调整数组顺序使奇数位于偶数前面。<br>题目：输入一个整数数组，调整数组中数字的顺序，使得所有奇数位于数组的前半部分，<br>所有偶数位于数组的后半部分。要求时间复杂度为O(n)。<br>ANSWER:<br>This problem makes me recall the process of partition in quick sort.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; (a[i] &amp; <span class="number">1</span>)==<span class="number">0</span>) i++;</span><br><span class="line"><span class="keyword">if</span> (i==n) <span class="keyword">return</span>;</span><br><span class="line">swap(a, i++, j++);</span><br><span class="line"><span class="keyword">while</span> (i&lt;n) &#123;</span><br><span class="line"><span class="keyword">if</span> ((a[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">swap(a, i, j++);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="55">
<li>题目：类CMyString 的声明如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">~CMyString(<span class="keyword">void</span>);</span><br><span class="line">CMyString&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br><span class="line">请实现其赋值运算符的重载函数，要求异常安全，即当对一个对象进行赋值时发生异常，对</span><br><span class="line">象的状态不能改变。</span><br><span class="line">ANSWER</span><br><span class="line">Pass…</span><br></pre></td></tr></table></figure></li>
<li>最长公共字串。<br>题目：如果字符串一的所有字符按其在字符串中的顺序出现在另外一个字符串二中，<br>则字符串一称之为字符串二的子串。<br>注意，并不要求子串（字符串一）的字符必须连续出现在字符串二中。<br>请编写一个函数，输入两个字符串，求它们的最长公共子串，并打印出最长公共子串。<br>例如：输入两个字符串BDCABA 和ABCBDAB，字符串BCBA 和BDAB 都是是它们的最长公共子串，则输出它们的长度4，并打印任意一个子串。<br>分析：求最长公共子串（Longest Common Subsequence, LCS）是一道非常经典的动态规划<br>题，因此一些重视算法的公司像MicroStrategy 都把它当作面试题。<br>ANSWER:<br>Standard DP…<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">lcs(ap1, bp2) = <span class="built_in">max</span>&#123; lcs(p1,p2)+<span class="number">1</span>, lcs(p1, bp2), lcs(ap1, p2)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> LCS(<span class="keyword">char</span> *p1, <span class="keyword">char</span> *p2) &#123;</span><br><span class="line"><span class="keyword">int</span> l1= <span class="built_in">strlen</span>(p1)+<span class="number">1</span>, l2=<span class="built_in">strlen</span>(p2)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a[l1*l2];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l1; i++) a[i*l2] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;l2; i++) a[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;l1; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;l2; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">max</span> = MAX(a[(i<span class="number">-1</span>)*l2+l1], a[i*l2+l1<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span> (p1[i<span class="number">-1</span>] == p2[j<span class="number">-1</span>]) &#123;</span><br><span class="line"><span class="built_in">max</span> = (<span class="built_in">max</span> &gt; <span class="number">1</span> + a[(i<span class="number">-1</span>)*l2+j<span class="number">-1</span>]) ? <span class="built_in">max</span> : <span class="number">1</span>+a[(i<span class="number">-1</span>)*l2+j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[l1*l2<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>用俩个栈实现队列。<br>题目：某队列的声明如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CQueue() &#123;&#125;</span><br><span class="line">~CQueue() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>; <span class="comment">// append a element to tail</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteHead</span><span class="params">()</span></span>; <span class="comment">// remove a element from head</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Stack&lt;T&gt; m_stack1;</span><br><span class="line">Stack&lt;T&gt; m_stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
分析：从上面的类的声明中，我们发现在队列中有两个栈。<br>因此这道题实质上是要求我们用两个栈来实现一个队列。<br>相信大家对栈和队列的基本性质都非常了解了：栈是一种后入先出的数据容器，<br>因此对队列进行的插入和删除操作都是在栈顶上进行；队列是一种先入先出的数据容器，<br>我们总是把新元素插入到队列的尾部，而从队列的头部删除元素。<br>ANSWER<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Traditional problem in CLRS.</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span> </span>&#123;</span><br><span class="line">m_stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!m_stack2.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">return</span> m_stack2.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_stack1.isEmpty()) error(“<span class="keyword">delete</span> from empty <span class="built_in">queue</span>”);</span><br><span class="line"><span class="keyword">while</span> (!m_stack1.isEmpty()) &#123;</span><br><span class="line">m_stack2.push(m_stack1.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_stack2.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>从尾到头输出链表。<br>题目：输入一个链表的头结点，从尾到头反过来输出每个结点的值。链表结点定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nKey;</span><br><span class="line">ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
分析：这是一道很有意思的面试题。<br>该题以及它的变体经常出现在各大公司的面试、笔试题中。<br>ANSWER<br>Have answered this…</li>
</ol>
<p>59.不能被继承的类。<br>题目：用C++设计一个不能被继承的类。<br>分析：这是Adobe 公司2007 年校园招聘的最新笔试题。<br>这道题除了考察应聘者的C++基本功底外，还能考察反应能力，是一道很好的题目。<br>ANSWER:<br>I don’t know c++.<br>Maybe it can be done by implement an empty private default constructor.</p>
<p>60.在O（1）时间内删除链表结点。<br>题目：给定链表的头指针和一个结点指针，在O(1)时间删除该结点。链表结点的定义如下：<br>struct ListNode<br>{<br>int m_nKey;<br>ListNode* m_pNext;<br>};<br>函数的声明如下：<br>void DeleteNode(ListNode* pListHead, ListNode* pToBeDeleted);<br>分析：这是一道广为流传的Google 面试题，能有效考察我们的编程基本功，还能考察我们<br>的反应速度，<br>更重要的是，还能考察我们对时间复杂度的理解。<br>ANSWER:<br>Copy the data from tobedeleted’s next to tobedeleted. then delete tobedeleted. The special case is tobedelete is the tail, then we must iterate to find its predecessor.<br>The amortized time complexity is O(1).</p>
<p>————————————————————————-<br>61.找出数组中两个只出现一次的数字<br>题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。<br>请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。<br>分析：这是一道很新颖的关于位运算的面试题。<br>ANSWER:<br>XOR.</p>
<p>62.找出链表的第一个公共结点。<br>题目：两个单向链表，找出它们的第一个公共结点。<br>链表的结点定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nKey;</span><br><span class="line">ListNode* m_pNext;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分析：这是一道微软的面试题。微软非常喜欢与链表相关的题目，<br>因此在微软的面试题中，链表出现的概率相当高。<br>ANSWER:<br>Have done this.</p>
<p>63.在字符串中删除特定的字符。<br>题目：输入两个字符串，从第一字符串中删除第二个字符串中所有的字符。例如，输入”They are students.”和”aeiou”， 则删除之后的第一个字符串变成”Thy r stdnts.”。<br>分析：这是一道微软面试题。在微软的常见面试题中，与字符串相关的题目占了很大的一部<br>分，因为写程序操作字符串能很好的反映我们的编程基本功。<br>ANSWER:<br>Have done this? Use a byte array / character hash to record second string. then use two pointers to shrink the 1st string.</p>
<ol start="64">
<li>寻找丑数。<br>题目：我们把只包含因子2、3 和5 的数称作丑数（Ugly Number）。例如6、8 都是丑数，<br>但14 不是，因为它包含因子7。习惯上我们把1 当做是第一个丑数。求按从小到大的顺序的第1500 个丑数。<br>分析：这是一道在网络上广为流传的面试题，据说google 曾经采用过这道题。<br>ANSWER:<br>TRADITIONAL.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Use heap/priority <span class="built_in">queue</span>.</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">no1500</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> heap[<span class="number">4500</span>];</span><br><span class="line">heap[<span class="number">0</span>] = <span class="number">2</span>; heap[<span class="number">1</span>] = <span class="number">3</span>; heap[<span class="number">2</span>] = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">1500</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> s = heap[<span class="number">0</span>];</span><br><span class="line">heap[<span class="number">0</span>] = s*<span class="number">2</span>; siftDown(heap, <span class="number">0</span>, <span class="built_in">size</span>);</span><br><span class="line">heap[<span class="built_in">size</span>] = s*<span class="number">3</span>; siftUp(heap, <span class="built_in">size</span>, <span class="built_in">size</span>+<span class="number">1</span>);</span><br><span class="line">heap[<span class="built_in">size</span>+<span class="number">1</span>] = s*<span class="number">5</span>; siftUp(heap, <span class="built_in">size</span>+<span class="number">1</span>, <span class="built_in">size</span>+<span class="number">2</span>);</span><br><span class="line"><span class="built_in">size</span>+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> heap[], <span class="keyword">int</span> from, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = from * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (c &lt; <span class="built_in">size</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (c+<span class="number">1</span>&lt;<span class="built_in">size</span> &amp;&amp; heap &lt; heap) c++;</span><br><span class="line"><span class="keyword">if</span> (heap &lt; heap[from]) swap(heap, c, from);</span><br><span class="line">from = c; c=from*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> heap[], <span class="keyword">int</span> from, <span class="keyword">int</span> <span class="built_in">size</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (from &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> p = (from – <span class="number">1</span>)  / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (heap[p] &gt; heap[from]) swap(heap, p, from);</span><br><span class="line">from = p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>输出1 到最大的N 位数<br>题目：输入数字n，按顺序输出从1 最大的n 位10 进制数。比如输入3，则输出1、2、3 一直到最大的3 位数即999。<br>分析：这是一道很有意思的题目。看起来很简单，其实里面却有不少的玄机。<br>ANSWER:<br>So maybe n could exceed i32? I cannot tell where is the trick…<br>Who will output 2*10^9 numbers…</li>
<li>颠倒栈。<br>题目：用递归颠倒一个栈。例如输入栈{1, 2, 3, 4, 5}，1 在栈顶。<br>颠倒之后的栈为{5, 4, 3, 2, 1}，5 处在栈顶。<br>ANSWER:<br>Interesting…<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack <span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">Object o = <span class="built_in">stack</span>.pop();</span><br><span class="line">reverse(<span class="built_in">stack</span>);</span><br><span class="line">putToBottom(<span class="built_in">stack</span>, o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putToBottom</span><span class="params">(Stack <span class="built_in">stack</span>, Object o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">stack</span>.isEmpty()) &#123;</span><br><span class="line"><span class="built_in">stack</span>.push(o);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object o2 = <span class="built_in">stack</span>.pop();</span><br><span class="line">putToBottom(<span class="built_in">stack</span>, o);</span><br><span class="line"><span class="built_in">stack</span>.push(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>俩个闲玩娱乐。</li>
<li>扑克牌的顺子<br>从扑克牌中随机抽5 张牌，判断是不是一个顺子，即这5 张牌是不是连续的。2-10 为数字本身，A 为1，J 为11，Q 为12，K 为13，而大小王可以看成任意数字。<br>ANSWER:</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make king = 0</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isStraight</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">Arrays.sort(a);</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] &gt; <span class="number">0</span>) <span class="keyword">return</span> checkGaps(a, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; a[<span class="number">1</span>] != <span class="number">0</span>) <span class="keyword">return</span> checkGaps(a, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> checkGaps(a, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkGaps</span><span class="params">(<span class="keyword">int</span> []a, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> allowGaps)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=s;</span><br><span class="line"><span class="keyword">while</span> (i&lt;e) &#123;</span><br><span class="line">allowGaps -= a[i+<span class="number">1</span>] – a[i] – <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (allowGaps &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.n 个骰子的点数。把n 个骰子扔在地上，所有骰子朝上一面的点数之和为S。输入n，<br>打印出S 的所有可能的值出现的概率。<br>ANSWER:<br>All the possible values includes n to 6n. All the event number is 6^n.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">For n&lt;=S&lt;=<span class="number">6</span>n, the number of events is f(S, n)</span><br><span class="line">f(S,n) = f(S<span class="number">-6</span>, n<span class="number">-1</span>) + f(S<span class="number">-5</span>, n<span class="number">-1</span>) + … + f(S<span class="number">-1</span>, n<span class="number">-1</span>)</span><br><span class="line">number of events that all dices are <span class="number">1</span>s is only <span class="number">1</span>, <span class="keyword">and</span> thus f(k, k) = <span class="number">1</span>, f(<span class="number">1</span><span class="number">-6</span>, <span class="number">1</span>) = <span class="number">1</span>, f(x, <span class="number">1</span>)=<span class="number">0</span> where x&lt;<span class="number">1</span> <span class="keyword">or</span> x&gt;<span class="number">6</span>, f(m, n)=<span class="number">0</span> where m&lt;n</span><br><span class="line">Can <span class="keyword">do</span> it in DP.</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> listAllProbabilities(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>*n+<span class="number">1</span>][];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">6</span>*n; i++) &#123;</span><br><span class="line">f[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">6</span>; i++) &#123;</span><br><span class="line">f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">f[i][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=<span class="number">6</span>*i; j++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=(j<span class="number">-6</span>&lt;i<span class="number">-1</span>)?i<span class="number">-1</span>:j<span class="number">-6</span>; k&lt;j<span class="number">-1</span>; k++)</span><br><span class="line">f[j][i] += f[k][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> p6 = Math.power(<span class="number">6</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=n; i&lt;=<span class="number">6</span>*n; i++) &#123;</span><br><span class="line">System.out.<span class="built_in">println</span>(“P(S=”+i+”)=”+((<span class="keyword">double</span>)f[i][n] / p6));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>68.把数组排成最小的数。<br>题目：输入一个正整数数组，将它们连接起来排成一个数，输出能排出的所有数字中最小的<br>一个。<br>例如输入数组{32, 321}，则输出这两个能排成的最小数字32132。<br>请给出解决问题的算法，并证明该算法。<br>分析：这是09 年6 月份百度的一道面试题，<br>从这道题我们可以看出百度对应聘者在算法方面有很高的要求。<br>ANSWER:<br>Actually this problem has little to do with algorithm…<br>The concern is, you must figure out how to arrange to achieve a smaller figure.<br>The answer is, if ab &lt; ba, then a &lt; b, and this is a total order.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">smallestDigit</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">Integer aux[] = <span class="keyword">new</span> Integer[a.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; a++) aux[i] = a[i];</span><br><span class="line">Arrays.sort(aux, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line"><span class="keyword">int</span> compareTo(Integer i1, Integer i2) &#123;</span><br><span class="line"><span class="keyword">return</span> (“”+i1+i2).compare(“”+i2+i1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;aux.length, i++) &#123;</span><br><span class="line">sb.append(aux[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>69.旋转数组中的最小元素。<br>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个<br>排好序的数组的一个旋转，<br>输出旋转数组的最小元素。例如数组{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数<br>组的最小值为1。<br>分析：这道题最直观的解法并不难。从头到尾遍历数组一次，就能找出最小的元素，时间复杂度显然是O(N)。但这个思路没有利用输入数组的特性，我们应该能找到更好的解法。<br>ANSWER<br>This is like the shifted array binary search problem. One blind point is that you may miss the part that the array is shifted by 0(or kN), that is not shifted.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shiftedMinimum</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t || a[s] &lt; a[t]) <span class="keyword">return</span> a[s];</span><br><span class="line"><span class="keyword">int</span> m = s + (t-s)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[s]&gt;a[m]) <span class="keyword">return</span> helper(a, s, m);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> helper(a, m+<span class="number">1</span>, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>70.给出一个函数来输出一个字符串的所有排列。<br>ANSWER 简单的回溯就可以实现了。当然排列的产生也有很多种算法，去看看组合数学，<br>还有逆序生成排列和一些不需要递归生成排列的方法。<br>印象中Knuth 的<TAOCP>第一卷里面深入讲了排列的生成。这些算法的理解需要一定的数学功底，也需要一定的灵感，有兴趣最好看看。<br>ANSWER:<br>Have done this.</p>
<p>71.数值的整数次方。<br>题目：实现函数double Power(double base, int exponent)，求base 的exponent 次方。<br>不需要考虑溢出。<br>分析：这是一道看起来很简单的问题。可能有不少的人在看到题目后30 秒写出如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> result = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= exponent; ++i)</span><br><span class="line">result *= base;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ANSWER</p>
<p>…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> <span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">1</span>) <span class="keyword">return</span> base;</span><br><span class="line"><span class="keyword">double</span> half = power(base, <span class="built_in">exp</span> &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> (((<span class="built_in">exp</span> &amp; <span class="number">1</span>) == <span class="number">1</span>) ? base : <span class="number">1.0</span>) * half * half;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="72">
<li>题目：设计一个类，我们只能生成该类的一个实例。<br>分析：只能生成一个实例的类是实现了Singleton 模式的类型。<br>ANSWER<br>I’m not good at multithread programming… But if we set a lazy initialization, the “if” condition could be interrupted thus multiple constructor could be called, so we must add synchronized to the if judgements, which is a loss of efficiency. Putting it to the static initialization will guarantee that the constructor only be executed once by the Java class loader.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"><span class="function"><span class="keyword">private</span> synchronized <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">This may <span class="keyword">not</span> be correct. I’m quite bad at <span class="keyword">this</span>…</span><br></pre></td></tr></table></figure></li>
<li>对策字符串的最大长度。<br>题目：输入一个字符串，输出该字符串中对称的子字符串的最大长度。比如输入字符串“google”，由于该字符串里最长的对称子字符串是“goog”，因此输出4。<br>分析：可能很多人都写过判断一个字符串是不是对称的函数，这个题目可以看成是该函数的<br>加强版。<br>ANSWER<br>Build a suffix tree of x and inverse(x), the longest anagram is naturally found.<br>Suffix tree can be built in O(n) time so this is a linear time solution.</li>
</ol>
<p>74.数组中超过出现次数超过一半的数字<br>题目：数组中有一个数字出现的次数超过了数组长度的一半，找出这个数字。<br>分析：这是一道广为流传的面试题，包括百度、微软和Google 在内的多家公司都<br>曾经采用过这个题目。要几十分钟的时间里很好地解答这道题，<br>除了较好的编程能力之外，还需要较快的反应和较强的逻辑思维能力。<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Delete every two different digits. The last one that left is the one.</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMajor</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">x = a[i]; cnt++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i]==x) &#123;</span><br><span class="line">cnt ++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cnt –;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>75.二叉树两个结点的最低共同父结点<br>题目：二叉树的结点定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nvalue;</span><br><span class="line">TreeNode* m_pLeft;</span><br><span class="line">TreeNode* m_pRight;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>输入二叉树中的两个结点，输出这两个结点在数中最低的共同父结点。<br>分析：求数中两个结点的最低共同结点是面试中经常出现的一个问题。这个问题至少有两个<br>变种。<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Have done <span class="keyword">this</span>. Do it again <span class="keyword">for</span> memory…</span><br><span class="line"><span class="function">TreeNode* <span class="title">getLCA</span><span class="params">(TreeNode* root, TreeNode* X, TreeNode *Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (X == root || Y == root) <span class="keyword">return</span> root;</span><br><span class="line">TreeNode * left = getLCA(root-&gt;m_pLeft, X, Y);</span><br><span class="line">TreeNode * right = getLCA(root-&gt;m_pRight, X, Y);</span><br><span class="line"><span class="keyword">if</span> (left == <span class="literal">NULL</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (right == <span class="literal">NULL</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>76.复杂链表的复制<br>题目：有一个复杂链表，其结点除了有一个m_pNext 指针指向下一个结点外，还有一个m_pSibling 指向链表中的任一结点或者NULL。其结点的C++定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComplexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> m_nValue;</span><br><span class="line">ComplexNode* m_pNext;</span><br><span class="line">ComplexNode* m_pSibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下图是一个含有5 个结点的该类型复杂链表。</p>
<p>图中实线箭头表示m_pNext 指针，虚线箭头表示m_pSibling 指针。为简单起见，指向NULL 的指针没有画出。请完成函数ComplexNode* Clone(ComplexNode* pHead)，以复制一个复杂链表。<br>分析：在常见的数据结构上稍加变化，这是一种很新颖的面试题。<br>要在不到一个小时的时间里解决这种类型的题目，我们需要较快的反应能力，<br>对数据结构透彻的理解以及扎实的编程功底。<br>ANSWER<br>Have heard this before, never seriously thought it.</p>
<p>The trick is like this: take use of the old pSibling, make it points to the new created cloned node, while make the new cloned node’s pNext backup the old pSibling.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComplexNode * <span class="title">Clone</span><span class="params">(ComplexNode* pHead)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">preClone(pHead);</span><br><span class="line">inClone(pHead);</span><br><span class="line"><span class="keyword">return</span> postClone(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preClone</span><span class="params">(ComplexNode* pHead)</span> </span>&#123;</span><br><span class="line">ComplexNode * p = <span class="keyword">new</span> ComplexNode();</span><br><span class="line">p-&gt;m_pNext = pHead-&gt;m_pSibling;</span><br><span class="line">pHead-&gt;m_pSibling = p;</span><br><span class="line"><span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">NULL</span>) preClone(pHead-&gt;m_pNext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inClone</span><span class="params">(ComplexNode * pHead)</span> </span>&#123;</span><br><span class="line">ComplexNode * pSib = pNew-&gt;m_pNext;</span><br><span class="line"><span class="keyword">if</span> (pSib == <span class="literal">NULL</span>) &#123; pNew-&gt;m_pSibling = <span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; pNew-&gt;m_pSibling = pSib-&gt;m_pSibling; &#125;</span><br><span class="line"><span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">NULL</span>) inClone(pHead-&gt;m_pNext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ComplexNode * <span class="title">postClone</span><span class="params">(ComplexNode * pHead)</span> </span>&#123;</span><br><span class="line">ComplexNode * pNew = pHead-&gt;m_pSibling;</span><br><span class="line">ComplexNode * pSib = pNew-&gt;m_pNext;</span><br><span class="line"><span class="keyword">if</span> (pHead-&gt;m_pNext != <span class="literal">NULL</span>) &#123;</span><br><span class="line">pNew-&gt;m_pNext = pHead-&gt;m_pNext-&gt;m_pSibling;</span><br><span class="line">pHead-&gt;m_pSibling = pSib;</span><br><span class="line">postClone(pHead-&gt;m_pNext);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pNew-&gt;pNext = <span class="literal">NULL</span>;</span><br><span class="line">pHead-&gt;m_pSibling = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pNew;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>77.关于链表问题的面试题目如下：<br>1.给定单链表，检测是否有环。<br>使用两个指针p1,p2 从链表头开始遍历，p1 每次前进一步，p2 每次前进两步。如果p2 到<br>达链表尾部，说明无环，否则p1、p2 必然会在某个时刻相遇(p1==p2)，从而检测到链表中有环。<br>2.给定两个单链表(head1, head2)，检测两个链表是否有交点，如果有返回第一个交点。如果head1==head2，那么显然相交，直接返回head1。否则，分别从head1,head2 开始遍历两个链表获得其长度len1 与len2，假设len1&gt;=len2，那么指针p1 由head1 开始向后移动len1-len2 步，指针p2=head2，下面p1、p2 每次向后前进一步并比较p1p2 是否相等，如果相等即返回该结点，否则说明两个链表没有交点。<br>3.给定单链表(head)，如果有环的话请返回从头结点进入环的第一个节点。<br>运用题一，我们可以检查链表中是否有环。如果有环，那么p1p2 重合点p 必然在环中。从p 点断开环，方法为：p1=p, p2=p-&gt;next, p-&gt;next=NULL。此时，原单链表可以看作两条单链表，一条从head 开始，另一条从p2 开始，于是运用题二的方法，我们找到它们的第一个交点即为所求。<br>4.只给定单链表中某个结点p(并非最后一个结点，即p-&gt;next!=NULL)指针，删除该结点。办法很简单，首先是放p 中数据,然后将p-&gt;next 的数据copy 入p 中，接下来删除p-&gt;next即可。<br>5.只给定单链表中某个结点p(非空结点)，在p 前面插入一个结点。办法与前者类似，首先分配一个结点q，将q 插入在p 后，接下来将p 中的数据copy 入q中，然后再将要插入的数据记录在p 中。</p>
<p>78.链表和数组的区别在哪里？<br>分析：主要在基本概念上的理解。<br>但是最好能考虑的全面一点，现在公司招人的竞争可能就在细节上产生，谁比较仔细，谁获胜的机会就大。<br>ANSWER</p>
<ol>
<li>Besides the common staff, linked list is more abstract and array is usually a basic real world object. When mentioning “linked list”, it doesn’t matter how it is implemented, that is, as long as it supports “get data” and “get next”, it is a linked list. But almost all programming languages provides array as a basic data structure.</li>
<li>So array is more basic. You can implement a linked list in an array, but cannot in the other direction.</li>
</ol>
<p>79.<br>1.编写实现链表排序的一种算法。说明为什么你会选择用这样的方法？<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">For linked <span class="built_in">list</span> sorting, usually mergesort is the best choice. Pros: O(<span class="number">1</span>) auxilary space, compared to <span class="built_in">array</span> merge sort. No node creation, just pointer operations.</span><br><span class="line"><span class="function">Node * <span class="title">linkedListMergeSort</span><span class="params">(Node * pHead)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = getLen(pHead);</span><br><span class="line"><span class="keyword">return</span> mergeSort(pHead, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">mergeSort</span><span class="params">(Node * p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">1</span>) &#123; p-&gt;next = <span class="literal">NULL</span>; <span class="keyword">return</span> p; &#125;</span><br><span class="line">Node * pmid = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++) &#123;</span><br><span class="line">pmid = pmid-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node * p1 = mergeSort(p, len/<span class="number">2</span>);</span><br><span class="line">Node * p2 = mergeSort(pmid, len – len/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> merge(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node * <span class="title">merge</span><span class="params">(Node * p1, Node * p2)</span> </span>&#123;</span><br><span class="line">Node * p = <span class="literal">NULL</span>, * ph = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p1!=<span class="literal">NULL</span> &amp;&amp; p2!=<span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p1-&gt;data&lt;p2-&gt;data) &#123;</span><br><span class="line"><span class="keyword">if</span> (ph == <span class="literal">NULL</span>) &#123;ph = p = p1;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; p-&gt;next = p1; p1 = p1-&gt;next; p = p-&gt;next;&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (ph == <span class="literal">NULL</span>) &#123;ph = p = p2;&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; p-&gt;next = p2; p2 = p2-&gt;next; p = p-&gt;next;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;next = (p1==<span class="literal">NULL</span>) ? p2 : p1;</span><br><span class="line"><span class="keyword">return</span> ph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.编写实现数组排序的一种算法。说明为什么你会选择用这样的方法？<br>ANSWER<br>Actually, it depends on the data. If arbitrary data is given in the array, I would choose quick sort. It is asy to implement, fast.</p>
<p>3.请编写能直接实现strstr()函数功能的代码。<br>ANSWER<br>Substring test? Have done this.</p>
<p>80.阿里巴巴一道笔试题<br>问题描述:<br>12 个高矮不同的人,排成两排,每排必须是从矮到高排列,而且第二排比对应的第一排的人<br>高,问排列方式有多少种?<br>这个笔试题,很YD,因为把某个递归关系隐藏得很深。<br>ANSWER<br>Must be<br>1 a b … …<br>c d e … …<br>c could be 2th to 7th ( has to be smaller than d, e… those 5 numbers),<br>so f(12) = 6 f(10) = 6* 5 f(8) = 30 * 4f(6) = 120<em>3f(4) = 360</em>2f(2) = 720</p>
<p>81.第1 组百度面试题<br>1.一个int 数组，里面数据无任何限制，要求求出所有这样的数a[i]，其左边的数都小于等于它，右边的数都大于等于它。能否只用一个额外数组和少量其它空间实现。<br>ANSWER<br>Sort the array to another array, compare it with the original array, all a[i] = b[i] are answers.</p>
<p>2.一个文件，内含一千万行字符串，每个字符串在1K 以内，要求找出所有相反的串对，如abc 和cba。<br>ANSWER</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">So we have ~10G data. It is unlikely to put them all into main memory. Anyway, calculate the hash of each line in the first round, at the second round calculate the hash of the reverse of the line and remembers only the line number pairs that the hashes of the two directions collides. The last round only test those lines.</span><br></pre></td></tr></table></figure>

<p>3.STL 的set 用什么实现的？为什么不用hash？<br>ANSWER<br>I don’t quite know. Only heard of that map in stl is implemented with red-black tree. One good thing over hash is that you don’t need to re-hash when data size grows.</p>
<p>82.第2 组百度面试题<br>1.给出两个集合A 和B，其中集合A={name}，<br>集合B={age、sex、scholarship、address、…}，<br>要求：<br>问题1、根据集合A 中的name 查询出集合B 中对应的属性信息；<br>问题2、根据集合B 中的属性信息（单个属性，如age&lt;20 等），查询出集合A 中对应的name。<br>ANSWER<br>SQL? Not a good defined question.</p>
<p>2.给出一个文件，里面包含两个字段{url、size}，即url 为网址，size 为对应网址访问的次数<br>要求：<br>问题1、利用Linux Shell 命令或自己设计算法，查询出url 字符串中包含“baidu”子字符串对应的size 字段值；<br>问题2、根据问题1 的查询结果，对其按照size 由大到小的排列。<br>（说明：url 数据量很大，100 亿级以上）<br>ANSWER</p>
<ol>
<li>shell: gawk ‘ /baidu/ { print $2 } ’ FILE</li>
<li>shell: gawk ‘ /baidu/ {print $2}’ FILE | sort -n -r</li>
</ol>
<p>83.第3 组百度面试题<br>1.今年百度的一道题目<br>百度笔试：给定一个存放整数的数组，重新排列数组使得数组左边为奇数，右边为偶数。<br>要求：空间复杂度O(1)，时间复杂度为O（n）。<br>ANSWER<br>Have done this.<br>2.百度笔试题<br>用C 语言实现函数void * memmove(void *dest, const void *src, size_t n)。memmove 函数的功能是拷贝src 所指的内存内容前n 个字节到dest 所指的地址上。<br>分析：<br>由于可以把任何类型的指针赋给void 类型的指针, 这个函数主要是实现各种数据类型的拷贝。<br>ANSWER<br>//To my memory, usually memcpy doesn’t check overlap, memmove do</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">memmove</span><span class="params">(<span class="keyword">void</span> * dest, <span class="keyword">const</span> <span class="keyword">void</span> * src, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dest==<span class="literal">NULL</span> || src == <span class="literal">NULL</span>) error(“<span class="literal">NULL</span> pointers”);</span><br><span class="line"><span class="keyword">byte</span> * psrc = (<span class="keyword">byte</span>*)src;</span><br><span class="line"><span class="keyword">byte</span> * pdest = (<span class="keyword">byte</span>*)dest;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (dest &lt; src + n) &#123;</span><br><span class="line">psrc = (<span class="keyword">byte</span>*)(src+n<span class="number">-1</span>);</span><br><span class="line">pdest = (<span class="keyword">byte</span>*)(dest+n<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">step</span> = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">pdest = psrc;</span><br><span class="line">pdest += <span class="built_in">step</span>; psrc += <span class="built_in">step</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>84.第4 组百度面试题<br>2010 年3 道百度面试题[相信，你懂其中的含金量]<br>1.a<del>z 包括大小写与0</del>9 组成的N 个数, 用最快的方式把其中重复的元素挑出来。<br>ANSWER</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">By fastest, so memory is not the problem, hash is the first choice. Or trie will do.</span><br><span class="line">Both run in O(Size) time, where size is the total size of the imput.</span><br></pre></td></tr></table></figure>
<p>2.已知一随机发生器，产生0 的概率是p，产生1 的概率是1-p，现在要你构造一个发生器，使得它构造0 和1 的概率均为1/2；构造一个发生器，使得它构造1、2、3 的概率均为1/3；…，构造一个发生器，使得它构造1、2、3、…n 的概率均为1/n，要求复杂度最低。<br>ANSWER</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Run rand() twice, we got 00, 01, 10 or 11. If it’s 00 or 11, discard it, else output 0 for 01, 1 for 10.</span><br><span class="line"></span><br><span class="line">Similarly, assume C(M, 2) &gt;&#x3D; n and C(M-1, 2) &lt; n. Do M rand()’s and get a binary string of M length. Assign 1100…0 to 1, 1010…0 to 2, …</span><br></pre></td></tr></table></figure>

<p>3.有10 个文件，每个文件1G，<br>每个文件的每一行都存放的是用户的query，每个文件的query 都可能重复。<br>要求按照query 的频度排序.<br>ANSWER<br>If there is no enough memory, do bucketing first. For each bucket calculate the frequency of each query and sort. Then combine all the frequencies with multiway mergesort.</p>
<p>85.又见字符串的问题<br>1.给出一个函数来复制两个字符串A 和B。字符串A 的后几个字节和字符串B 的前几个字节重叠。分析：记住，这种题目往往就是考你对边界的考虑情况。<br>ANSWER<br>Special case of memmove.</p>
<p>2.已知一个字符串，比如asderwsde,寻找其中的一个子字符串比如sde 的个数，如果没有返回0，有的话返回子字符串的个数。<br>ANSWER<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_of_substr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span> * sub)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> * p = str;</span><br><span class="line"><span class="keyword">int</span> n = <span class="built_in">strlen</span>(sub);</span><br><span class="line"><span class="keyword">while</span> ( *p != ‘\<span class="number">0</span>’ ) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strncmp</span>(p, sub, n) == <span class="number">0</span>) count ++;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Also recursive way works. Possible optimizations like Sunday algorithm or Rabin-Karp algorithm will do.</p>
<p>86.<br>怎样编写一个程序，把一个有序整数数组放到二叉树中？<br>分析:本题考察二叉搜索树的建树方法，简单的递归结构。关于树的算法设计一定要联想到递归，因为树本身就是递归的定义。而，学会把递归改称非递归也是一种必要的技术。毕竟，递归会造成栈溢出，关于系统底层的程序中不到非不得以最好不要用。但是对某些数学问题，就一定要学会用递归去解决。<br>ANSWER<br>This is the first question I’m given in a google interview.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node * <span class="title">array2Tree</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(<span class="built_in">array</span>, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node * <span class="title">helper</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start &gt; <span class="built_in">end</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> m = start + (<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">Node * root = <span class="keyword">new</span> Node(<span class="built_in">array</span>[m]);</span><br><span class="line">root-&gt;left = helper(<span class="built_in">array</span>, start, m<span class="number">-1</span>);</span><br><span class="line">root-&gt;right = helper(<span class="built_in">array</span>, m+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>87.<br>1.大整数数相乘的问题。（这是2002 年在一考研班上遇到的算法题）<br>ANSWER<br>Do overflow manually.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> mask = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) – <span class="number">1</span>;</span><br><span class="line"><span class="function">ArrayList&lt;Integer&gt; <span class="title">multiply</span><span class="params">(ArrayList &lt;Integer&gt; a, ArrayList&lt;Integer&gt; b)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(a.<span class="built_in">size</span>()*b.<span class="built_in">size</span>()+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">multiply(b, a.<span class="built_in">get</span>(i), i, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiply</span><span class="params">(ArrayList&lt;Integer&gt; x, <span class="keyword">int</span> a, <span class="keyword">int</span> base, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="built_in">overflow</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;x.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">long</span> tmp = x.<span class="built_in">get</span>(i) * a + result.<span class="built_in">get</span>(base+i) + <span class="built_in">overflow</span>;</span><br><span class="line">result.<span class="built_in">set</span>(base+i, (<span class="keyword">int</span>)(mask &amp; tmp));</span><br><span class="line"><span class="built_in">overflow</span> = (tmp &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">overflow</span> != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">long</span> tmp = result.<span class="built_in">get</span>(base+i) + <span class="built_in">overflow</span>;</span><br><span class="line">result.<span class="built_in">set</span>(base+i, (<span class="keyword">int</span>) (mask &amp; tmp));</span><br><span class="line"><span class="built_in">overflow</span> = (tmp &gt;&gt; <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.求最大连续递增数字串（如“ads3sl456789DF3456ld345AA”中的“456789”）<br>ANSWER<br>Have done this.</p>
<p>3.实现strstr 功能，即在父串中寻找子串首次出现的位置。<br>（笔试中常让面试者实现标准库中的一些函数）<br>ANSWER<br>Have done this.</p>
<p>88.2005 年11 月金山笔试题。编码完成下面的处理函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">函数将字符串中的字符’*’移到串的前部分，前面的非’*’字符后移，但不能改变非’*’字符的先后顺序，函数返回串中字符’*’的数量。如原始串为：ab**cd**e*12，处理后为*****abcde12，函数并返回值为5。（要求使用尽量少的时间和辅助空间）</span><br><span class="line">ANSWER</span><br><span class="line">It’s like partition in quick sort. Just keep the non-* part stable.</span><br><span class="line"></span><br><span class="line">int partitionStar(char a[]) &#123;</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line">int i &#x3D; a.length-1, j&#x3D;a.length-1; &#x2F;&#x2F; i for the cursor, j for the first non-* char</span><br><span class="line">while (i &gt;&#x3D; 0) &#123;</span><br><span class="line">if (a[i] !&#x3D; ‘*’) &#123;</span><br><span class="line">swap(a, i–, j–);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">i–; count ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>89.神州数码、华为、东软笔试题<br>1.2005 年11 月15 日华为软件研发笔试题。实现一单链表的逆转。<br>ANSWER<br>Have done this.</p>
<p>2.编码实现字符串转整型的函数（实现函数atoi 的功能），据说是神州数码笔试题。如将字符串”+123”123, ”-0123”-123, “123CS45”123, “123.45CS”123, “CS123.45”0<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*a==’+’) <span class="keyword">return</span> atoi(a+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a==’-’) <span class="keyword">return</span> – atoi(a+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">char</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*p &gt;= ‘<span class="number">0</span>’ &amp;&amp; *p &lt;= ‘<span class="number">9</span>’) &#123;</span><br><span class="line">c = c*<span class="number">10</span> + (*p – ‘<span class="number">0</span>’);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.快速排序（东软喜欢考类似的算法填空题，又如堆排序的算法等）<br>ANSWER<br>Standard solution. Skip.</p>
<p>4.删除字符串中的数字并压缩字符串。如字符串”abc123de4fg56”处理后变为”abcdefg”。注意空间和效率。（下面的算法只需要一次遍历，不需要开辟新空间，时间复杂度为O(N)）<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Also partition, keep non-digit stable.</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">partition</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> * i = str;  <span class="comment">// i for cursor, j for the first digit char;</span></span><br><span class="line"><span class="keyword">char</span> * j = str;</span><br><span class="line"><span class="keyword">while</span> (*i != ‘\<span class="number">0</span>’) &#123;</span><br><span class="line"><span class="keyword">if</span> (*i &gt; ‘<span class="number">9</span>’ || *i &lt; ‘<span class="number">0</span>’) &#123;</span><br><span class="line">*j++ = *i++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*j = ‘\<span class="number">0</span>’;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.求两个串中的第一个最长子串（神州数码以前试题）。<br>如”abractyeyt”,”dgdsaeactyey”的最大子串为”actyet”。<br>ANSWER<br>Use suffix tree. The longest common substring is the longest prefix of the suffixes.<br>O(n) to build suffix tree. O(n) to find the lcs.</p>
<p>90.<br>1.不开辟用于交换数据的临时空间，如何完成字符串的逆序<br>(在技术一轮面试中，有些面试官会这样问)。<br>ANSWER<br>Two cursors.</p>
<p>2.删除串中指定的字符<br>（做此题时，千万不要开辟新空间，否则面试官可能认为你不适合做嵌入式开发）<br>ANSWER<br>Have done this.</p>
<p>3.判断单链表中是否存在环。<br>ANSWER<br>Have done this.</p>
<p>91<br>1.一道著名的毒酒问题<br>有1000 桶酒，其中1 桶有毒。而一旦吃了，毒性会在1 周后发作。现在我们用小老鼠做实验，要在1 周内找出那桶毒酒，问最少需要多少老鼠。<br>ANSWER<br>Have done this. 10 mices.</p>
<p>2.有趣的石头问题<br>有一堆1 万个石头和1 万个木头，对于每个石头都有1 个木头和它重量一样，<br>把配对的石头和木头找出来。<br>ANSWER<br>Quick sort.</p>
<p>92.<br>1.多人排成一个队列,我们认为从低到高是正确的序列,但是总有部分人不遵守秩序。如果说,前面的人比后面的人高(两人身高一样认为是合适的), 那么我们就认为这两个人是一对“捣乱分子”,比如说,现在存在一个序列:<br>176, 178, 180, 170, 171<br>这些捣乱分子对为<br>&lt;176, 170&gt;, &lt;176, 171&gt;, &lt;178, 170&gt;, &lt;178, 171&gt;, &lt;180, 170&gt;, &lt;180, 171&gt;,<br>那么,现在给出一个整型序列,请找出这些捣乱分子对的个数(仅给出捣乱分子对的数目即可,不用具体的对)<br>要求：<br>输入:<br>为一个文件(in)，文件的每一行为一个序列。序列全为数字，数字间用”,”分隔。<br>输出：<br>为一个文件(out)，每行为一个数字，表示捣乱分子的对数。<br>详细说明自己的解题思路，说明自己实现的一些关键点。<br>并给出实现的代码，并分析时间复杂度。<br>限制：<br>输入每行的最大数字个数为100000 个，数字最长为6 位。程序无内存使用限制。<br>ANSWER<br>The answer is the swap number of insertion sort. The straightforward method is to do insertion sort and accumulate the swap numbers, which is slow: O(n^2)</p>
<p>A sub-quadratic solution can be done by DP.</p>
<p>f(n) = f(n-1) + Index(n)<br>Index(n), which is to determine how many numbers is smaller than a[n] in a[0..n-1], can be done in log(n) time using BST with subtree size.</p>
<p>93.在一个int 数组里查找这样的数，它大于等于左侧所有数，小于等于右侧所有数。直观想法是用两个数组a、b。a[i]、b[i]分别保存从前到i 的最大的数和从后到i 的最小的数，一个解答：这需要两次遍历，然后再遍历一次原数组，将所有data[i]&gt;=a[i-1]&amp;&amp;data[i]&lt;=b[i]的data[i]找出即可。给出这个解答后，面试官有要求只能用一个辅助数组，且要求少遍历一次。<br>ANSWER<br>It is natural to improve the hint… just during the second traversal, do the range minimum and picking together. There is no need to store the range minimums.</p>
<p>94.微软笔试题<br>求随机数构成的数组中找到长度大于=3 的最长的等差数列, 输出等差数列由小到大:<br>如果没有符合条件的就输出<br>格式：<br>输入[1,3,0,5,-1,6]<br>输出[-1,1,3,5]<br>要求时间复杂度，空间复杂度尽量小<br>ANSWER<br>Firstly sort the array. Then do DP: for each a[i], update the length of the arithmetic sequences. That’s a O(n^3) solution. Each arithmetic sequence can be determined by the last item and the step size.</p>
<p>95.华为面试题<br>1 判断一字符串是不是对称的，如：abccba<br>ANSWER<br>Two cursors.</p>
<p>2.用递归的方法判断整数组a[N]是不是升序排列<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAscending</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isAscending(a, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAscending</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> start == a.length – <span class="number">1</span> || isAscending(a, start+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>96.08 年中兴校园招聘笔试题<br>1．编写strcpy 函数<br>已知strcpy 函数的原型是<br>char *strcpy(char *strDest, const char *strSrc);<br>其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数strcpy<br>ANSWER</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *strDest, <span class="keyword">const</span> <span class="keyword">char</span> *strSrc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (strSrc == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *i = strSrc, *j = strDest;</span><br><span class="line"><span class="keyword">while</span> (*i != ‘\<span class="number">0</span>’) &#123;</span><br><span class="line">*j++ = *i++;</span><br><span class="line">&#125;</span><br><span class="line">*j = ‘\<span class="number">0</span>’;</span><br><span class="line"><span class="keyword">return</span> strDest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Maybe you need to check if src and dest overlaps, then decide whether to copy from tail to head.</p>
<p>97.第1 组微软较简单的算法面试题<br>1.编写反转字符串的程序，要求优化速度、优化空间。<br>ANSWER<br>Have done this.</p>
<p>2.在链表里如何发现循环链接？<br>ANSWER<br>Have done this.</p>
<p>3.编写反转字符串的程序，要求优化速度、优化空间。<br>ANSWER<br>Have done this.</p>
<p>4.给出洗牌的一个算法，并将洗好的牌存储在一个整形数组里。<br>ANSWER<br>Have done this.</p>
<p>5.写一个函数，检查字符是否是整数，如果是，返回其整数值。<br>（或者：怎样只用4 行代码编写出一个从字符串到长整形的函数？）<br>ANSWER<br>Char or string?<br>have done atoi;</p>
<p>98.第2 组微软面试题<br>1.给出一个函数来输出一个字符串的所有排列。<br>ANSWER<br>Have done this…</p>
<p>2.请编写实现malloc()内存分配函数功能一样的代码。<br>ANSWER<br>Way too hard as an interview question…<br>Please check wikipedia for solutions…</p>
<p>3.给出一个函数来复制两个字符串A 和B。字符串A 的后几个字节和字符串B 的前几个字节重叠。<br>ANSWER<br>Copy from tail to head.</p>
<p>4.怎样编写一个程序，把一个有序整数数组放到二叉树中？<br>ANSWER<br>Have done this.</p>
<p>5.怎样从顶部开始逐层打印二叉树结点数据？请编程。<br>ANSWER<br>Have done this…</p>
<p>6.怎样把一个链表掉个顺序（也就是反序，注意链表的边界条件并考虑空链表）？<br>ANSWER<br>Have done this…</p>
<p>99.第3 组微软面试题<br>1.烧一根不均匀的绳，从头烧到尾总共需要1 个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？<br>ANSWER<br>May have done this… burn from both side gives ½ hour.</p>
<p>2.你有一桶果冻，其中有黄色、绿色、红色三种，闭上眼睛抓取同种颜色的两个。抓取多少个就可以确定你肯定有两个同一颜色的果冻？（5 秒-1 分钟）<br>ANSWER<br>4.</p>
<p>3.如果你有无穷多的水，一个3 公升的提捅，一个5 公升的提捅，两只提捅形状上下都不均<br>匀，问你如何才能准确称出4 公升的水？（40 秒-3 分钟）<br>ANSWER</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 to 3 &#x3D;&gt; 2</span><br><span class="line">2 to 3, remaining 1</span><br><span class="line">5 to remaining 1 &#x3D;&gt; 4</span><br></pre></td></tr></table></figure>
<p>一个岔路口分别通向诚实国和说谎国。<br>来了两个人，已知一个是诚实国的，另一个是说谎国的。<br>诚实国永远说实话，说谎国永远说谎话。现在你要去说谎国，<br>但不知道应该走哪条路，需要问这两个人。请问应该怎么问？（20 秒-2 分钟）<br>ANSWER<br>Seems there are too many answers.<br>I will pick anyone to ask: how to get to your country? Then pick the other way.</p>
<p>100.第4 组微软面试题，挑战思维极限<br>1.12 个球一个天平，现知道只有一个和其它的重量不同，问怎样称才能用三次就找到那个<br>球。13 个呢？（注意此题并未说明那个球的重量是轻是重，所以需要仔细考虑）（5 分钟-1 小时）<br>ANSWER<br>Too complicated. Go find brain teaser answers by yourself.</p>
<p>2.在9 个点上画10 条直线，要求每条直线上至少有三个点？（3 分钟-20 分钟）</p>
<p>3.在一天的24 小时之中，时钟的时针、分针和秒针完全重合在一起的时候有几次？都分别是什么时间？你怎样算出来的？（5 分钟-15 分钟）</p>
<p>说明：如果你是第一次看到这种题，并且以前从来没有见过类似的题型，<br>并且能够在半个小时之内做出答案，说明你的智力超常..）<br>1.第一题. 五个海盗抢到了100 颗宝石，每一颗都一样大小和价值连城。他们决定这么分：<br>抽签决定自己的号码（1、2、3、4、5）<br>首先，由1 号提出分配方案，然后大家表决，当且仅当超过半数的人同意时，<br>按照他的方案进行分配，否则将被扔进大海喂鲨鱼<br>如果1 号死后，再由2 号提出分配方案，然后剩下的4 人进行表决，<br>当且仅当超过半数的人同意时，按照他的方案进行分配，否则将被扔入大海喂鲨鱼。<br>依此类推<br>条件：每个海盗都是很聪明的人，都能很理智地做出判断，从而做出选择。<br>问题：第一个海盗提出怎样的分配方案才能使自己的收益最大化？<br>Answer:<br>A traditional brain teaser.<br>Consider #5, whatever #4 proposes, he won’t agree, so #4 must agree whatever #3 proposes. So if there are only #3-5, #3 should propose (100, 0, 0). So the expected income of #3 is 100, and #4 and #5 is 0 for 3 guy problem. So whatever #2 proposes, #3 won’t agree, but if #2 give #4 and #5 $1, they can get more than 3-guy subproblem. So #2 will propose (98, 0, 1, 1). So for #1, if give #2 less than $98, #2 won’t agree. But he can give #3 $1 and #4 or #5 $2, so this is a (97, 0, 1, 2, 0) solution.</p>
<p>2.一道关于飞机加油的问题，已知：<br>每个飞机只有一个油箱，<br>飞机之间可以相互加油（注意是相互，没有加油机）<br>一箱油可供一架飞机绕地球飞半圈，<br>问题：<br>为使至少一架飞机绕地球一圈回到起飞时的飞机场，至少需要出动几架飞机？<br>（所有飞机从同一机场起飞，而且必须安全返回机场，不允许中途降落，中间没有飞机场）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章，未经许可，任何单位及个人不得做营利性使用！如有侵权请联系作者。
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2016/06/linux-%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            linux-相关笔记
          
        </div>
      </a>
    
    
      <a href="/2016/06/linux-%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E4%BB%8B%E7%BB%8D/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">linux-各个版本介绍</div>
      </a>
    
  </nav>

  
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> Tianye Zhai
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.svg" alt="Tianye Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  
  if(document.getElementsByClassName("tocbot").length !== 0){
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      scrollContainer: 'main',
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto'
    });
  }
</script>

<script src="/comm/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/comm/jquery.modal.min.css">
<script src="/comm/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="/comm/photoswipe_dist/photoswipe.css">
<link rel="stylesheet" href="/comm/photoswipe_dist/default-skin/default-skin.css">
<script src="/comm/photoswipe_dist/photoswipe.min.js"></script>
<script src="/comm/photoswipe_dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="/comm/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>