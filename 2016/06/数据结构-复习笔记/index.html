<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="翟天野 天野 翟天野博客 tianye zhaitianye" />
   
  <meta name="description" content="The seeker of the world" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    数据结构-复习笔记 |  Tianye Blog
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/comm/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="/comm/pace.min.js"></script>

  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?a65f4359920e6c4b5b2b6d0519751045";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-数据结构-复习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  数据结构-复习笔记
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/2016/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2016-06-21T12:30:40.000Z" itemprop="datePublished">2016-06-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">14k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">52 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      



  
    <div class="article-entry" itemprop="articleBody">
       
  <p>第一章 概  论</p>
<p>1.数据：信息的载体,能被计算机识别、存储和加工处理。</p>
<p>2.数据元素：数据的基本单位，可由若干个数据项组成，数据项是具有独立含义的最小标识单位。</p>
<p>3.数据结构：数据之间的相互关系，即数据的组织形式。<br>它包括：</p>
<p>1）数据的逻辑结构，从逻辑关系上描述数据，与数据存储无关，独立于计算机；</p>
<p>2）数据的存储结构，是逻辑结构用计算机语言的实现，依赖于计算机语言。</p>
<p>3）数据的运算，定义在逻辑结构上，每种逻辑结构都有一个运算集合。常用的运算：检索/插入/删除/更新/排序。</p>
<p>4.数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的存储结构是逻辑结构用计算机语言的实现。</p>
<p>5.数据类型：一个值的集合及在值上定义的一组操作的总称。分为：原子类型和结构类型。</p>
<p>6.抽象数据类型：抽象数据的组织和与之相关的操作。优点：将数据和操作封装在一起实现了信息隐藏。</p>
<ol start="7">
<li>抽象数据类型ADT：是在概念层上描述问题；类：是在实现层上描述问题；在应用层上操作对象（类的实例）解决问题。</li>
</ol>
<p>8.数据的逻辑结构，简称为数据结构，有：</p>
<p>（1）线性结构，若结构是非空集则仅有一个开始和终端结点，并且所有结点最多只有一个直接前趋和后继。</p>
<p>（2）非线性结构，一个结点可能有多个直接前趋和后继。</p>
<p>9.数据的存储结构有：<br>1）顺序存储，把逻辑相邻的结点存储在物理上相邻的存储单元内。</p>
<p>2）链接存储，结点间的逻辑关系由附加指针字段表示。</p>
<p>3）索引存储，存储结点信息的同时，建立附加索引表，有稠密索引和稀疏索引。</p>
<p>4）散列存储，按结点的关键字直接计算出存储地址。</p>
<p>10.评价算法的好坏是：算法是正确的；执行算法所耗的时间；执行算法的存储空间（辅助存储空间）；易于理解、编码、调试。</p>
<p>11.算法的时间复杂度T(n)：是该算法的时间耗费，是求解问题规模n的函数。记为O(n)。</p>
<p>时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n^2)、立方阶O(n^3)、……k次方阶O(n^k)、指数阶O(2^n)。13.算法的空间复杂度S(n)：是该算法的空间耗费，是求解问题规模n的函数。</p>
<p>12.算法衡量：是用时间复杂度和空间复杂度来衡量的，它们合称算法的复杂度。</p>
<p>13.算法中语句的频度不仅与问题规模有关，还与输入实例中各元素的取值相关。</p>
<p>第 二 章   线 性 表</p>
<p>1.线性表：是由n(n≥0)个数据元素组成的有限序列。</p>
<p>2.线性表的基本运算有：</p>
<p>1）InitList(L),构造空表，即表的初始化；</p>
<p>2）ListLength(L),求表的结点个数，即表长；</p>
<p>3）GetNode(L,i),取表中第i个结点，要求1≤i≤ListLength(L)；</p>
<p>4）LocateNode(L,x)查找L中值为x的结点并返回结点在L中的位置，有多个x则返回首个，没有则返回特殊值表示查找失败。</p>
<p>5）InsertList(L,x,i)在表的第i个位置插入值为x的新结点，要求1≤i≤ListLength(L)+1；</p>
<p>6）DeleteList(L,i)删除表的第i个位置的结点，要求1≤i≤ListLength(L)；</p>
<p>3.顺序表：把线性表的结点按逻辑次序存放在一组地址连续的存储单元里。</p>
<p>4.顺序表结点的存储地址计算公式：Loc(ai)=Loc(a1)+(i-1)*C；1≤i≤n</p>
<p>5.顺序表上的基本运算</p>
<p>（1）插入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertlist</span><span class="params">(seqlist *L,datatype x,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length+<span class="number">1</span>)</span><br><span class="line">error(“<span class="built_in">position</span> error”);</span><br><span class="line"><span class="keyword">if</span>(L-&gt;length&gt;=listsize)</span><br><span class="line">error(“<span class="built_in">overflow</span>”);</span><br><span class="line"><span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span>;j&gt;=i<span class="number">-1</span>;j–)</span><br><span class="line">L-&gt;data[j+<span class="number">1</span>]=L-&gt;data[j];  结点后移</span><br><span class="line">L-&gt;data[i<span class="number">-1</span>]=x;</span><br><span class="line">L-&gt;length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在顺序表上插入要移动表的n/2结点，算法的平均时间复杂度为O(n)。<br>（2）删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span> <span class="params">(seqlist *L,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;L-&gt;length)</span><br><span class="line">error(“<span class="built_in">position</span> error”);</span><br><span class="line"><span class="keyword">for</span>(j=i;j&lt;=L-&gt;length<span class="number">-1</span>;j++)</span><br><span class="line">L-&gt;data[j<span class="number">-1</span>]=L-&gt;data[j];  结点前移</span><br><span class="line">L-&gt;length–;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在顺序表上删除要移动表的（n+1）/2结点，算法的平均时间复杂度为O(n)。</p>
<p>6.单链表：只有一个链域的链表称单链表。<br>在结点中存储结点值和结点的后继结点的地址，data  next  data是数据域，next是指针域。<br>（1）建立单链表。时间复杂度为O(n)。<br>加头结点的优点：1）链表第一个位置的操作无需特殊处理；2）将空表和非空表的处理统一。<br>（2）查找运算。时间复杂度为O(n)。<br>1） 按序号查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Listnode * <span class="title">getnode</span><span class="params">(linklist head,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">listnode *p;</span><br><span class="line">p=head;j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next&amp;&amp;j&lt;i)&#123;</span><br><span class="line">p=p-&gt;next; 指针下移</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>） 按值查找。</span><br><span class="line"><span class="function">Listnode * <span class="title">locatenode</span><span class="params">(linklist head ,datatype key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">listnode *p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p&amp;&amp;p-&gt;data!=key)</span><br><span class="line">p=p-&gt;next;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）插入运算。时间复杂度为O(n)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">insertlist</span><span class="params">(linklist head ,datatype x, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">listnode *p;</span><br><span class="line">p=getnode(head,i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>);</span><br><span class="line">error(“<span class="built_in">position</span> error”);</span><br><span class="line">s=(listnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(listnode));</span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4） 删除运算。时间复杂度为O(n)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">deletelist</span><span class="params">(linklist head ,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">listnode *p ,*r;</span><br><span class="line">p=getnode(head ,i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>||p-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">error(“<span class="built_in">position</span> error”);</span><br><span class="line">r=p-&gt;next;</span><br><span class="line">p-&gt;next=r-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.循环链表：是一种首尾相连的链表。特点是无需增加存储量，仅对表的链接方式修改使表的处理灵活方便。</p>
<p>8.空循环链表仅由一个自成循环的头结点表示。</p>
<p>9.很多时候表的操作是在表的首尾位置上进行，此时头指针表示的单循环链表就显的不够方便，改用尾指针rear来表示单循环链表。用头指针表示的单循环链表查找开始结点的时间是O(1),查找尾结点的时间是O(n)；用尾指针表示的单循环链表查找开始结点和尾结点的时间都是O(1)。</p>
<p>10.在结点中增加一个指针域，prior|data|next。形成的链表中有两条不同方向的链称为双链表。</p>
<p>1) 双链表的前插操作。时间复杂度为O(1)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">dinsertbefore</span><span class="params">(dlistnode *p ,datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dlistnode *s=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dlistnode));</span><br><span class="line">s-&gt;data=x;</span><br><span class="line">s-&gt;prior=p-&gt;prior;</span><br><span class="line">s-&gt;next=p;</span><br><span class="line">p-&gt;prior-&gt;next=s;</span><br><span class="line">p-&gt;prior=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2) 双链表的删除操作。时间复杂度为O(1)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">ddeletenode</span><span class="params">(dlistnode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p-&gt;prior-&gt;next=p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior=p-&gt;prior;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.顺序表和链表的比较<br>1） 基于空间的考虑：顺序表的存储空间是静态分配的，链表的存储空间是动态分配的。顺序表的存储密度比链表大。因此，在线性表长度变化不大，易于事先确定时，宜采用顺序表作为存储结构。</p>
<p>2） 基于时间的考虑：顺序表是随机存取结构，若线性表的操作主要是查找，很少有插入、删除操作时，宜用顺序表结构。对频繁进行插入、删除操作的线性表宜采用链表。若操作主要发生在表的首尾时采用尾指针表示的单循环链表。</p>
<p>12.存储密度=（结点数据本身所占的存储量）/（整个结点结构所占的存储总量）<br>存储密度：顺序表=1，链表&lt;1。</p>
<p>第 三 章   栈 和 队 列</p>
<p>1.栈是限制仅在表的一端进行插入和删除运算的线性表又称为后进先出表（LIFO表）。插入、删除端称为栈顶，另一端称栈底。表中无元素称空栈。</p>
<p>2.栈的基本运算有：</p>
<p>1） initstack(s),构造一个空栈；</p>
<p>2） stackempty(s),判栈空；</p>
<p>3） stackfull(s),判栈满；</p>
<p>4） push(s,x),进栈；</p>
<p>5） pop (s),退栈；</p>
<p>6） stacktop(s)，取栈顶元素。</p>
<p>3.顺序栈：栈的顺序存储结构称顺序栈。</p>
<p>4.当栈满时，做进栈运算必定产生空间溢出，称“上溢”。 当栈空时，做退栈运算必定产生空间溢出，称“下溢”。上溢是一种错误应设法避免，下溢常用作程序控制转移的条件。</p>
<p>5.在顺序栈上的基本运算：<br>1） 置空栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">initstack</span><span class="params">(seqstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s-&gt;top=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2)判栈空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stackempty</span><span class="params">(seqstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s-&gt;top==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)判栈满。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stackfull</span><span class="params">(seqstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s-&gt;top==stacksize<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4)进栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">push</span><span class="params">(seqstack *s,datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(stackfull(s))</span><br><span class="line">error(“<span class="built_in">stack</span> <span class="built_in">overflow</span>”);</span><br><span class="line">s-&gt;data[++s-&gt;top]=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5)退栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datatype <span class="title">pop</span><span class="params">(seqstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(stackempty(s))</span><br><span class="line">error(“<span class="built_in">stack</span> underflow”);</span><br><span class="line"><span class="keyword">return</span> S-&gt;data[s-&gt;top–];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6)取栈顶元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dtatatype <span class="title">stacktop</span><span class="params">(seqstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(stackempty(s))</span><br><span class="line">error(“<span class="built_in">stack</span> underflow”);</span><br><span class="line"><span class="keyword">return</span> S-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.链栈：栈的链式存储结构称链栈。栈顶指针是链表的头指针。</p>
<p>7.链栈上的基本运算：<br>1） 建栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">initstack</span><span class="params">(linkstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s-&gt;top=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2)判栈空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Int <span class="title">stackempty</span> <span class="params">(linkstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s-&gt;top==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3) 进栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">push</span><span class="params">(linkstack *s,datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stacknode *p=(stacknode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(stacknode));</span><br><span class="line">p-&gt;data=x;</span><br><span class="line">p-&gt;next=s-&gt;top;</span><br><span class="line">s-&gt;top=p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4) 退栈。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datatype <span class="title">pop</span><span class="params">(linksatck *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">datatype x;</span><br><span class="line">stacknode *p=s-&gt;top;</span><br><span class="line"><span class="keyword">if</span>(stackempty(s))</span><br><span class="line">error(“<span class="built_in">stack</span> underflow”);</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">s-&gt;top=p-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5) 取栈顶元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datatype <span class="title">stacktop</span><span class="params">(linkstack *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(stackempty(s))</span><br><span class="line">error(“<span class="built_in">stack</span> is empty”);</span><br><span class="line"><span class="keyword">return</span> s-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.队列是一种运算受限的线性表，允许删除的一端称队首，允许插入的一端称队尾。队列又称为先进先出线性表，FIFO表。</p>
<p>9.队列的基本运算：</p>
<p>1） initqueue(q),置空队；</p>
<p>2） queueempty(q),判队空；</p>
<p>3） queuefull(q),判队满；</p>
<p>4） enqueue(q,x),入队；</p>
<p>5） dequeue(q),出队；</p>
<p>6） queuefront(q),返回队头元素。</p>
<p>10.顺序队列：队列的顺序存储结构称顺序队列。设置front和rear指针表示队头和队尾元素在向量空间的位置。</p>
<p>11.顺序队列中存在“假上溢”现象，由于入队和出队操作使头尾指针只增不减导致被删元素的空间无法利用，队尾指针超过向量空间的上界而不能入队。</p>
<p>12.为克服“假上溢”现象，将向量空间想象为首尾相连的循环向量，存储在其中的队列称循环队列。i=(i+1)%queuesize</p>
<p>13.循环队列的边界条件处理：由于无法用front==rear来判断队列的“空”和“满”。</p>
<p>解决的方法有：</p>
<p>1） 另设一个布尔变量以区别队列的空和满；</p>
<p>2） 少用一个元素，在入队前测试rear在循环意义下加1是否等于front；</p>
<p>3） 使用一个记数器记录元素总数。</p>
<p>14.循环队列的基本运算：</p>
<p>1) 置队空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">initqueue</span><span class="params">(cirqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q-&gt;front=q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">q-&gt;count=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2) 判队空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Int queueempty(cirqueue *q)</span><br><span class="line">&#123;</span><br><span class="line">return q-&gt;count&#x3D;&#x3D;0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3) 判队满。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Int <span class="title">queuefull</span><span class="params">(cirqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> q-&gt;count==queuesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4) 入队。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">enqueue</span><span class="params">(cirqueue *q ,datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(queuefull(q))</span><br><span class="line">error(“<span class="built_in">queue</span> overfolw”);</span><br><span class="line">q-&gt;count++;</span><br><span class="line">q-&gt;data[q-&gt;rear]=x;</span><br><span class="line">q-&gt;rear=(q-&gt;rear+<span class="number">1</span>)%queuesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5) 出队。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datatype <span class="title">dequeue</span><span class="params">(cirqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">datatype temp;</span><br><span class="line"><span class="keyword">if</span>(queueempty(q))</span><br><span class="line">error(“<span class="built_in">queue</span> underflow”);</span><br><span class="line">temp=q-&gt;data[q-&gt;front];</span><br><span class="line">q-&gt;count–;</span><br><span class="line">q-&gt;front=(q-&gt;front+<span class="number">1</span>)%queuesize;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6) 取队头元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datatype <span class="title">queuefront</span><span class="params">(cirqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(queueempty(q))</span><br><span class="line">error(“<span class="built_in">queue</span> is empty”);</span><br><span class="line"><span class="keyword">return</span> q-&gt;data[q-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15.链队列：队列的链式存储结构称链队列，链队列由一个头指针和一个尾指针唯一确定。</p>
<p>16.链队列的基本运算：</p>
<p>1) 建空队。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">initqueue</span><span class="params">(linkqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q-&gt;front=q-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2) 判队空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Int <span class="title">queueempty</span><span class="params">(linkqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> q-&gt;front==<span class="literal">NULL</span>&amp;&amp;q-&gt;rear==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3) 入队。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Void <span class="title">enqueue</span><span class="params">(linkqueue *q,datatype x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queuenode *p=(queuenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(queuenode));</span><br><span class="line">p-&gt;data=x;</span><br><span class="line">p-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(queueempty(q))</span><br><span class="line">q-front=q-&gt;rear=p;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q-&gt;rear-&gt;next=p;</span><br><span class="line">q-&gt;rear=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4) 出队。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datatype <span class="title">dequeue</span><span class="params">(linkqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">datatype x;</span><br><span class="line">queuenode *p;</span><br><span class="line"><span class="keyword">if</span>(queueempty(q))</span><br><span class="line">error(“<span class="built_in">queue</span> is underflow”);</span><br><span class="line">p=q-&gt;front;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">q-&gt;front=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(q-&gt;rear==p) q-&gt;rear=<span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5) 取队头元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Datatype <span class="title">queuefront</span><span class="params">(linkqueue *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(queueempty(q))</span><br><span class="line">error(“<span class="built_in">queue</span> is empty”);</span><br><span class="line"><span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 四 章   串</p>
<p>1.串：是由零个或多个字符组成的有限序列；包含字符的个数称串的长度；</p>
<p>2.空串：长度为零的串称空串；     空白串：由一个或多个空格组成的串称空白串；</p>
<p>子串：串中任意个连续字符组成的子序列称该串的子串；    主串：包含子串的串称主串；</p>
<p>子串的首字符在主串中首次出现的位置定义为子串在主串中的位置；</p>
<p>3.空串是任意串的子串；  任意串是自身的子串；</p>
<p>串常量在程序中只能引用但不能改变其值； 串变量取值可以改变；</p>
<p>4.串的基本运算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1） int strlen(char *s);求串长。</span><br><span class="line">2） char *strcpy(char * to,char * from);串复制。</span><br><span class="line">3） char *strcat(char * to,char * from);串联接。</span><br><span class="line">4） int strcmp(char *s1,char *s2);串比较。</span><br><span class="line">5） char *strchr(char *s,char c);字符定位。</span><br></pre></td></tr></table></figure>

<p>5.串的存储结构：<br>（1）串的顺序存储：串的顺序存储结构称顺序串。按存储分配不同分为：<br>1） 静态存储分配的顺序串：<br>直接用定长的字符数组定义，以“/0”表示串值终结。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxstrsize 256</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> seqstring[maxstrsize];</span><br><span class="line">seqstring s;</span><br></pre></td></tr></table></figure>

<p>不设终结符，用串长表示。<br>Typedef struct{<br>Char ch[maxstrsize];<br>Int length;<br>}seqstring;</p>
<p>以上方式的缺点是：串值空间大小是静态的，难以适应插入、链接等操作。</p>
<p>2） 动态存储分配的顺序串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简单定义：typedef char * string;</span><br><span class="line">复杂定义：typedef struct&#123;</span><br><span class="line">char *ch;</span><br><span class="line">int length;</span><br><span class="line">&#125;hstring;</span><br></pre></td></tr></table></figure>

<p>（2）串的链式存储：串的链式存储结构称链串。链串由头指针唯一确定。类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linkstrnode;</span><br><span class="line"><span class="keyword">typedef</span> linkstrnode *linkstring;</span><br><span class="line">linkstring s;</span><br></pre></td></tr></table></figure>
<p>将结点数据域存放的字符个数定义为结点的大小。结点大小不为1的链串类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nodesize 80</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> data[nodesize];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;linkstrnode;</span><br></pre></td></tr></table></figure>
<p>6.串运算的实现<br>（1）顺序串上的子串定位运算。<br>1）子串定位运算又称串的模式匹配或串匹配。主串称目标串；子串称模式串。<br>2）朴素的串匹配算法。时间复杂度为O(n^2)。比较的字符总次数为（n-m+1）m。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Int <span class="title">naivestrmatch</span><span class="params">(seqstring t,seqstring p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">int</span> m=p.length;</span><br><span class="line"><span class="keyword">int</span> n=t.length;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n-m;i++)&#123;</span><br><span class="line">j=<span class="number">0</span>;k=i;</span><br><span class="line"><span class="keyword">while</span>(j&lt;m&amp;&amp;t.ch[k]==p.ch[j])&#123;</span><br><span class="line">j++;k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j==m) <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> –<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）链串上的子串定位运算。时间复杂度为O(n^2)。比较的字符总次数为（n-m+1）m。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Linkstrnode * <span class="title">lilnkstrmatch</span><span class="params">(linkstring T, linkstring P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">linkstrnode *shift, *t, *p;</span><br><span class="line">shift=T;</span><br><span class="line">t=shift;p=P;</span><br><span class="line"><span class="keyword">while</span>(t&amp;&amp;p)&#123;</span><br><span class="line"><span class="keyword">if</span>(t-&gt;data==p-&gt;data)&#123;</span><br><span class="line">t=t-&gt;next;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">shift=shift-&gt;next;</span><br><span class="line">t=shift;</span><br><span class="line">p=P;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> shift;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 五 章    多 维 数 组 和 广 义 表</p>
<p>1.多维数组：一般用顺序存储的方式表示数组。</p>
<p>2.常用方式有：1）行优先顺序，将数组元素按行向量排列；<br>2）列优先顺序，将数组元素按列向量排列。</p>
<p>3.计算地址的函数：LOC(Aij)=LOC(Ac1c2)+((i-c1)<em>(d2-c2+1)+j-c2)</em>d</p>
<p>4.矩阵的压缩存储：为多个非零元素分配一个存储空间；对零元素不分配存储空间。</p>
<p>（1） 对称矩阵：在一个n阶的方阵A中，元素满足Aij=Aji 0&lt;=i,j&lt;=n-1;称为对称矩阵。<br>元素的总数为：n(n+1)/2;<br>设：I=i或j中大的一个数；J=i或j中小的一个数；<br>则：k=I<em>(I+1)/2+J;<br>地址计算：LOC(Aij)=LOC(sa[k])=LOC(sa[0])+k*d= LOC(sa[0])+ (I</em>(I+1)/2+J )*d</p>
<p>（2）三角矩阵：以主对角线划分，三角矩阵有上三角和下三角；上三角的主对角线下元素均为常数c；下三角的主对角线上元素均为常数c。<br>元素总数为：(n(n+1)/2)+1;<br>以行优先顺序存放的Aij与SA[k]的关系：<br>上三角阵：k=i<em>(2n-i+1)/2+j-i;<br>下三角阵：k=i</em>(i+1)/2+j;</p>
<p>（3）对角矩阵：所有的非零元素集中在以主对角线为中心的带状区域，相邻两侧元素均为零。|i-j|&gt;(k-1)/2<br>以行优先顺序存放的Aij与SA[k]的关系：k=2i+j;</p>
<p>5.稀疏矩阵：当矩阵A中有非零元素S个，且S远小于元素总数时，称为稀疏矩阵。<br>对其压缩的方法有顺序存储和链式存储。</p>
<p>（1）三元组表：将表示稀疏矩阵的非零元素的三元组（行号、列号、值）按行或列优先的顺序排列得到的一个结点均是三元组的线性表，将该表的线性存储结构称为三元组表。其类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxsize 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> datatype;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">datatype v;</span><br><span class="line">&#125;trituplenode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">trituplenode data[maxsize];</span><br><span class="line"><span class="keyword">int</span> m,n,t;</span><br><span class="line">&#125;tritupletable;</span><br></pre></td></tr></table></figure>

<p>（2）带行表的三元组表：在按行优先存储的三元组表中加入一个行表记录每行的非零元素在三元组表中的起始位置。类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxrow 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">tritulpenode data[maxsize];</span><br><span class="line"><span class="keyword">int</span> rowtab[maxrow];</span><br><span class="line"><span class="keyword">int</span> m, n, t;</span><br><span class="line">&#125;rtritulpetable;</span><br></pre></td></tr></table></figure>
<p>6.广义表：是线性表的推广，广义表是n个元素的有限序列，元素可以是原子或一个广义表，记为LS。</p>
<p>7.若元素是广义表称它为LS的子表。若广义表非空，则第一个元素称表头，其余元素称表尾。</p>
<p>8.表的深度是指表展开后所含括号的层数。</p>
<p>9.把与树对应的广义表称为纯表，它限制了表中成分的共享和递归；</p>
<p>10.允许结点共享的表称为再入表；</p>
<p>11.允许递归的表称为递归表；</p>
<p>12.相互关系：线性表∈纯表∈再入表∈递归表；</p>
<p>13.广义表的特殊运算：1）取表头head(LS)；2）取表尾tail(LS);</p>
<p>第 六 章   树</p>
<p>1.树：是n个结点的有限集T，T为空时称空树，否则满足：<br>1）有且仅有一个特定的称为根的结点；<br>2）其余结点可分为m个互不相交的子集，每个子集本身是一棵树，并称为根的子树。<br>2.树的表示方法：1）树形表示法；2）嵌套集合表示法；3）凹入表表示法；4）广义表表示法；<br>3.一个结点拥有的子树数称为该结点的度；一棵树的度是指树中结点最大的度数。<br>4.度为零的结点称叶子或终端结点；度不为零的结点称分支结点或非终端结点<br>5.根结点称开始结点，根结点外的分支结点称内部结点；<br>6.树中某结点的子树根称该结点的孩子；该结点称为孩子的双亲；<br>7.树中存在一个结点序列K1，K2，…Kn，使Ki为Ki+1的双亲，则称该结点序列为K1到Kn的路径或道路；<br>8.树中结点K到Ks间存在一条路径，则称K是Ks的祖先，Ks是K的子孙；<br>9.结点的层数从根算起，若根的层数为1，则其余结点层数是其双亲结点层数加1；双亲在同一层的结点互为堂兄弟；树中结点最大层数称为树的高度或深度；<br>10.树中每个结点的各个子树从左到右有次序的称有序树，否则称无序树；<br>11.森林是m棵互不相交的树的集合。</p>
<p>12.二叉树：是n个结点的有限集，它或为空集，或由一个根结点及两棵互不相交的、分别称为该根的左子树和右子树的二叉树组成。<br>13.二叉树不是树的特殊情况，这是两种不同的数据结构；它与无序树和度为2的有序树不同。<br>14.二叉树的性质：<br>1） 二叉树第i层上的结点数最多为2^(i-1)；<br>2） 深度为k的二叉树至多有2^k-1个结点；<br>3） 在任意二叉树中，叶子数为n0，度为2的结点数为n2，则n0=n2+1；<br>15.满二叉树是一棵深度为k的且有2^k-1个结点的二叉树；<br>16.完全二叉树是至多在最下两层上结点的度数可以小于2，并且最下层的结点集中在该层最左的位置的二叉树；<br>17.具有N个结点的完全二叉树的深度为log2N取整加1；<br>18.二叉树的存储结构<br>（1）顺序存储结构：把一棵有n个结点的完全二叉树，从树根起自上而下、从左到右对所有结点编号，然后依次存储在一个向量b[0<del>n]中，b[1</del>n]存放结点，b[0]存放结点总数。<br>各个结点编号间的关系：<br>1） i=1是根结点；i&gt;1则双亲结点是i/2取整；<br>2） 左孩子是2i, 右孩子是2i+1；（要小于n）<br>3） i&gt;（n/2取整）的结点是叶子；<br>4） 奇数没有右兄弟，左兄弟是i-1；<br>5） 偶数没有左兄弟，右兄弟是i+1；<br>（2）链式存储结构<br>结点的结构为：lchild|data|rchild ；相应的类型说明：<br>typedef char data;<br>typedef struct node{<br>datatype data;<br>structnode *lchild , *rchild;<br>}bintnode;<br>typedef bintnode * bintree;<br>19.在二叉树中所有类型为bintnode的结点和一个指向开始结点的bintree类型的头指针构成二叉树的链式存储结构称二叉链表。<br>20.二叉链表由根指针唯一确定。在n个结点的二叉链表中有2n个指针域，其中n+1个为空。</p>
<p>21.二叉树的遍历方式有：前序遍历、中序遍历、后序遍历。时间复杂度为O(n)。<br>22.线索二叉树：利用二叉链表中的n+1个空指针域存放指向某种遍历次序下的前趋和后继结点的指针，这种指针称线索。加线索的二叉链表称线索链表。相应二叉树称线索二叉树。<br>23.线索链表结点结构：lchild|ltag|data|rtag|rchild；ltag=0,lchild是指向左孩子的指针；ltag=1,lchild是指向前趋的线索；rtag=0,rchild是指向右孩子的指针；rtag=1,rchild是指向后继的线索；<br>24.查找*p在指定次序下的前趋和后继结点。算法的时间复杂度为O(h)。线索对查找前序前趋和后序后继帮助不大。<br>25.遍历线索二叉树。时间复杂度为O(n)。</p>
<p>26.树、森林与二叉树的转换<br>（1）树、森林与二叉树的转换<br>1）树与二叉树的转换：1}所有兄弟间连线；2}保留与长子的连线，去除其它连线。该二叉树的根结点的右子树必为空。<br>2）森林与二叉树的转换：1}将所有树转换成二叉树；2}将所有树根连线。<br>（2）二叉树与树、森林的转换。是以上的逆过程。<br>27.树的存储结构<br>（1）双亲链表表示法：为每个结点设置一个parent指针，就可唯一表示任何一棵树。Data|parent<br>（2）孩子链表表示法：为每个结点设置一个firstchild指针，指向孩子链表头指针，链表中存放孩子结点序号。Data|firstchild。<br>（3双亲孩子链表表示法：将以上方法结合。Data|parent|firstchild<br>（4）孩子兄弟链表表示法：附加两个指向左孩子和右兄弟的指针。Leftmostchild|data|rightsibling<br>28.树和森林的遍历：前序遍历一棵树等价于前序遍历对应二叉树；后序遍历等价于中序遍历对应二叉树。</p>
<p>29.最优二叉树（哈夫曼树）：树的路径长度是从树根到每一结点的路径长度之和。将树中的结点赋予实数称为结点的权。<br>30.结点的带权路径是该结点的路径长度与权的乘积。树的带权路径长度又称树的代价，是所有叶子的带权路径长度之和。<br>31.带权路径长度最小的二叉树称最优二叉树（哈夫曼树）。<br>32.具有2n-1个结点其中有n个叶子，并且没有度为1的分支结点的树称为严格二叉树。<br>33.哈夫曼编码<br>34.对字符集编码时，要求字符集中任一字符的编码都不是其它字符的编码前缀，这种编码称前缀码。<br>35.字符出现频度与码长乘积之和称文件总长；字符出现概率与码长乘积之和称平均码长；<br>36.使文件总长或平均码长最小的前缀码称最优前缀码<br>37.利用哈夫曼树求最优前缀码，左为0，右为1。编码平均码长最小；没有叶子是其它叶子的祖先，不可能出现重复前缀。</p>
<p>第 七 章   图</p>
<p>1.图：图G是由顶点集V和边集E组成，顶点集是有穷非空集，边集是有穷集；<br>2.G中每条边都有方向称有向图；有向边称弧；边的始点称弧尾；边的终点称弧头；G中每条边都没有方向的称无向图。</p>
<p>3.顶点n与边数e的关系：无向图的边数e介于0<del>n(n-1)/2之间，有n(n-1)/2条边的称无向完全图；有向图的边数e介于0</del>n(n-1)之间，有n(n-1)条边的称有向完全图；<br>4.无向图中顶点的度是关联与顶点的边数；有向图中顶点的度是入度与出度的和。<br>所有图均满足：所有顶点的度数和的一半为边数。</p>
<p>5.图G（V，E），如V’是V的子集，E’是E的子集，且E’中关联的顶点均在V’中，则G’(V’,E’)是G的子图。</p>
<p>6.在有向图中，从顶点出发都有路径到达其它顶点的图称有根图；<br>7.在无向图中，任意两个顶点都有路径连通称连通图；极大连通子图称连通分量；<br>8.在有向图中，任意顺序两个顶点都有路径连通称强连通图；极大连通子图称强连通分量；</p>
<p>9.将图中每条边赋上权，则称带权图为网络。</p>
<p>10.图的存储结构：<br>（1）邻接矩阵表示法：邻接矩阵是表示顶点间相邻关系的矩阵。n个顶点就是n阶方阵。<br>无向图是对称矩阵；有向图行是出度，列是入度。<br>（2）邻接表表示法：对图中所有顶点，把与该顶点相邻接的顶点组成一个单链表，称为邻接表，adjvex|next,如要保存顶点信息加入data；对所有顶点设立头结点，vertex|firstedge,并顺序存储在一个向量中；vertex保存顶点信息，firstedge保存邻接表头指针。<br>11.邻接矩阵表示法与邻接表表示法的比较：<br>1） 邻接矩阵是唯一的，邻接表不唯一；<br>2） 存储稀疏图用邻接表，存储稠密图用邻接矩阵；<br>3） 求无向图顶点的度都容易，求有向图顶点的度邻接矩阵较方便；<br>4） 判断是否是图中的边，邻接矩阵容易，邻接表最坏时间为O(n)；<br>5） 求边数e，邻接矩阵耗时为O(n^2)，与e无关，邻接表的耗时为O(e+n)；</p>
<p>12.图的遍历：<br>（1）图的深度优先遍历：类似与树的前序遍历。按访问顶点次序得到的序列称DFS序列。<br>对邻接表表示的图深度遍历称DFS，时间复杂度为O(n+e); 对邻接矩阵表示的图深度遍历称DFSM，时间复杂度为O(n^2);<br>（2）图的广度优先遍历：类似与树的层次遍历。按访问顶点次序得到的序列称BFS序列。<br>对邻接表表示的图广度遍历称BFS，时间复杂度为O(n+e); 对邻接矩阵表示的图广度遍历称BFSM，时间复杂度为O(n^2);</p>
<ol start="13">
<li>将没有回路的连通图定义为树称自由树。</li>
<li>生成树：连通图G的一个子图若是一棵包含G中所有顶点的树，该子图称生成树。<br>有DFS生成树和BFS生成树，BFS生成树的高度最小。<br>非连通图生成的是森林。</li>
<li>最小生成树：将权最小的生成树称最小生成树。（是无向图的算法）<br>（1）普里姆算法：<br>1） 确定顶点S、初始化候选边集T[0~n-2]；formvex|tovex|lenght<br>2） 选权值最小的T[i]与第1条记录交换；<br>3） 从T[1]中将tovex取出替换以下记录的fromvex计算权；若权小则替换，否则不变；<br>4） 选权值最小的T[i]与第2条记录交换；<br>5） 从T[2]中将tovex取出替换以下记录的fromvex计算权；若权小则替换，否则不变；<br>6） 重复n-1次。<br>初始化时间是O(n),选轻边的循环执行n-1-k次，调整轻边的循环执行n-2-k；算法的时间复杂度为O(n^2)，适合于稠密图。<br>（2）克鲁斯卡尔算法：<br>1） 初始化确定顶点集和空边集；对原边集按权值递增顺序排序；<br>2） 取第1条边，判断边的2个顶点是不同的树，加入空边集，否则删除；<br>3） 重复e次。<br>对边的排序时间是O(elog2e)；初始化时间为O(n)；执行时间是O(log2e)；算法的时间复杂度为O(elog2e)，适合于稀疏图。</li>
</ol>
<ol start="16">
<li>路径的开始顶点称源点，路径的最后一个顶点称终点；</li>
<li>单源最短路径问题：已知有向带权图，求从某个源点出发到其余各个顶点的最短路径；</li>
<li>单目标最短路径问题：将图中每条边反向，转换为单源最短路径问题；</li>
<li>单顶点对间最短路径问题：以分别对不同顶点转换为单源最短路径问题；</li>
<li>所有顶点对间最短路径问题：分别对图中不同顶点对转换为单源最短路径问题；</li>
</ol>
<p>21.迪杰斯特拉算法：<br>1） 初始化顶点集S[i],路径权集D[i],前趋集P[i]；<br>2） 设置S[s]为真，D[s]为0；<br>3） 选取D[i]最小的顶点加入顶点集；<br>4） 计算非顶点集中顶点的路径权集；<br>5） 重复3）n-1次。<br>算法的时间复杂度为O(n^2)。</p>
<p>22.拓扑排序：对一个有向无环图进行拓扑排序，是将图中所有顶点排成一个线性序列，满足弧尾在弧头之前。这样的线性序列称拓扑序列。<br>（1）无前趋的顶点优先：总是选择入度为0的结点输出并删除该顶点的所有边。<br>设置各个顶点入度时间是O(n+e)，设置栈或队列的时间是O(n)，算法时间复杂度为O(n+e)。<br>（2）无后继的顶点优先：总是选择出度为0的结点输出并删除该顶点的所有边。<br>设置各个顶点出度时间是O(n+e)，设置栈或队列的时间是O(n)，算法时间复杂度为O(n+e)。<br>求得的是逆拓扑序列。</p>
<p>第 八 章   排 序</p>
<p>1.文件：由一组记录组成，记录有若干数据项组成，唯一标识记录的数据项称关键字；<br>2.排序是将文件按关键字的递增（减）顺序排列；</p>
<p>3.排序文件中有相同的关键字时，若排序后相对次序保持不变的称稳定排序，否则称不稳定排序；</p>
<p>4.在排序过程中，文件放在内存中处理不涉及数据的内、外存交换的称内排序，反之称外排序；</p>
<p>5.排序算法的基本操作：1）比较关键字的大小；2）改变指向记录的指针或移动记录本身。</p>
<p>6.评价排序方法的标准：1）执行时间；2）所需辅助空间，辅助空间为O(1)称就地排序；另要注意算法的复杂程度。</p>
<p>7.若关键字类型没有比较运算符，可事先定义宏或函数表示比较运算。</p>
<p>8.插入排序<br>（1）直接插入排序<br>算法中引入监视哨R[0]的作用是：1）保存R[i]的副本；2）简化边界条件，防止循环下标越界。<br>关键字比较次数最大为(n+2)(n-1)/2；记录移动次数最大为(n+4)(n-1)/2；<br>算法的最好时间是O(n)；最坏时间是O(n^2)；平均时间是O(n^2)；是一种就地的稳定的排序；<br>（2）希尔排序<br>实现过程：是将直接插入排序的间隔变为d。d的取值要注意：1）最后一次必为1；2）避免d值互为倍数；<br>关键字比较次数最大为n^1.25；记录移动次数最大为1.6n^1.25；<br>算法的平均时间是O(n^1.25)；是一种就地的不稳定的排序；</p>
<p>9.交换排序<br>（1）冒泡排序<br>实现过程：从下到上相邻两个比较，按小在上原则扫描一次，确定最小值，重复n-1次。<br>关键字比较次数最小为n-1、最大为n(n-1)/2；记录移动次数最小为0，最大为3n(n-1)/2；<br>算法的最好时间是O(n)；最坏时间是O(n^2)；平均时间是O(n^2)；是一种就地的稳定的排序；<br>（2）快速排序<br>实现过程：将第一个值作为基准，设置i,j指针交替从两头与基准比较，有交换后,交换j，i。i=j时确定基准，并以其为界限将序列分为两段。重复以上步骤。<br>关键字比较次数最好为nlog2n+nC(1)、最坏为n(n-1)/2；<br>算法的最好时间是O(nlog2n)；最坏时间是O(n^2)；平均时间是O(nlog2n)；辅助空间为O(log2n)；是一种不稳定排序；</p>
<p>10.选择排序<br>（1）直接选择排序<br>实现过程：选择序列中最小的插入第一位，在剩余的序列中重复上一步，共重复n-1次。<br>关键字比较次数为n(n-1)/2；记录移动次数最小为0，最大为3(n-1)；<br>算法的最好时间是O(n^2)；最坏时间是O(n^2)；平均时间是O(n^2)；是一种就地的不稳定的排序；<br>（2）堆排序<br>实现过程：把序列按层次填入完全二叉树，调整位置使双亲大于或小于孩子，建立初始大根或小根堆，调整树根与最后一个叶子的位置，排除该叶子重新调整位置。<br>算法的最好时间是O(nlog2n)；最坏时间是O(nlog2n)；平均时间是O(nlog2n)；是一种就地的不稳定排序；</p>
<p>11.归并排序<br>实现过程：将初始序列分为2个一组，最后单数轮空，对每一组排序后作为一个单元，对2个单元排序，直到结束。<br>算法的最好时间是O(nlog2n)；最坏时间是O(nlog2n)；平均时间是O(nlog2n)；辅助空间为O(n)；是一种稳定排序；</p>
<p>12.分配排序<br>（1）箱排序<br>实现过程：按关键字的取值范围确定箱子的个数，将序列按关键字放入箱中，输出非空箱的关键字。<br>在桶内分配和收集，及对各桶进行插入排序的时间为O(n),算法的期望时间是O(n),最坏时间是O(n^2)。<br>（2）基数排序<br>实现过程：按基数设置箱子，对关键字从低位到高位依次进行箱排序。<br>算法的最好时间是O(d<em>n+d</em>rd)；最坏时间是O(d<em>n+d</em>rd)；平均时间是O(d<em>n+d</em>rd)；辅助空间O(n+rd)；是一种稳定排序；</p>
<p>13.各种内部排序方法的比较和选择：<br>（1）按平均时间复杂度分为：</p>
<p>1) 平方阶排序：直接插入、直接选择、冒泡排序；<br>2) 线性对数阶：快速排序、堆排序、归并排序；<br>3) 指数阶：希尔排序；<br>4) 线性阶：箱排序、基数排序。</p>
<p>（2）选择合适排序方法的因素：<br>1)待排序的记录数；2)记录的大小；3)关键字的结构和初始状态；4)对稳定性的要求；<br>5)语言工具的条件；6)存储结构；  7)时间和辅助空间复杂度。</p>
<p>（3）结论：</p>
<p>1) 若规模较小可采用直接插入或直接选择排序；<br>2) 若文件初始状态基本有序可采用直接插入、冒泡或随机快速排序；<br>3) 若规模较大可采用快速排序、堆排序或归并排序；<br>4) 任何借助于比较的排序，至少需要O(nlog2n)的时间，箱排序和基数排序只适用于有明显结构特征的关键字；<br>5) 有的语言没有提供指针及递归，使归并、快速、基数排序算法复杂；<br>6) 记录规模较大时为避免大量移动记录可用链表作为存储结构，如插入、归并、基数排序，但快速、堆排序在链表上难以实现，可提取关键字建立索引表，然后对索引表排序。</p>
<p>第 九 章   查 找</p>
<p>1.查找的同时对表做修改操作(如插入或删除)则相应的表称之为动态查找表，否则称之为静态查找表。<br>2.衡量一个查找算法次序优劣的标准是在查找过程中对关键字需要执行的平均比较次数(即平均查找长度ASL).</p>
<p>3.线性表上进行查找的方法主要有三种：顺序查找、二分查找和分块查找。<br>（1）顺序查找的算法基本思想：是从表的一端开始顺序扫描线性表，依次将扫描到的结点关键字与给定值K比较，若当前扫描到的结点关键字与k相等则查找成功；若扫描结束后，仍未找到关键字等于K的结点，则查找失败。<br>1）顺序查找方法可用链式存储结构和顺序存储结构实现。<br>2）在顺序存储结构的顺序查找算法中所设的哨兵是为了简化循环的边界条件而引入的附加结点(元素)，其作用是使for循环中省去判定防止下标越界的条件从而节省了比较的时间。<br>3）在等概率情况下，查找成功时其平均查找长度约为表长的一半(n+1)/2.查找失败的话其平均查找长度为n+1.<br>（2）二分查找(又称折半查找)，它的算法思想：是对一有序表中的元素，从初始的查找区间开始，每经过一次与当前查找区间的中点位置上的结点关键字进行比较，若相等，则查找成功，否则，当前查找区间的缩小一半，按k值大小在某半个区间内重复相同的步骤进行查找，直到查找成功或失败为止。<br>1）二分查找在等概率的情况下查找成功的平均查找长度ASL为lg(n+1)-1,在查找失败时所需比较的关键字个数不超过判定树的深度，最坏情况下查找成功的比较次数也不超过判定树的深度┌lg(n+1)┐(不小于lg(n+1)的最小整数)<br>2）二分查找只适用于顺序存储结构而不能用链式存储结构实现。因为链表无法进行随机访问，如果要访问链表的中间结点，就必须先从头结点开始进行依次访问，这就要浪费很多时间，还不如进行顺序查找，而且，用链存储结构将无法判定二分的过程是否结束，因此无法用链表实现二分查找。<br>（3）分块查找(又称索引顺序查找)的基本思想：是将原表分成若干块，各块内部不一定有序，但表中的块是”分块有序”的，并抽取各块中的最大关键字及其起始位置建立索引表。因为索引表是有序的，分块查找就是先用二分查找或顺序查找确定待查结点在哪一块，然后在已确定的块中进行顺序查找(不能用二分查找，因为块内是无序的)。分块查找实际上是两次查找过程，它的算法效率介与顺序查找和二分查找之间。</p>
<p>4.以上三种查找方法的比较如下表：<br>查找算法 存储结构 优点 缺点 适用于<br>顺序查找 顺序结构<br>链表结构  算法简单且对表的结构无任何要求 查找效率低 n较小的表的查找和查找较少但改动较多的表(用链表作存储结构)<br>二分查找 顺序结构 查找效率高 关键字要有序且只能用顺序存储结构实现 特别适用于一经建立就很少改动又经常需要查找的线性表<br>分块查找 顺序结构<br>链表  在表中插入或删除记录时就只要在该记录所属块内操作，因为块内记录的存放是随意的，所以插入和删除比较容易 要增加一个辅助数组的存储空间，并要进行将初始表分块排序运算 适用于有分块特点的记录，如一个学校的学生登记表可按系号或班号分块。<br>5.树的查找：以树做为表的组织形式有一个好处，就是可以实现对动态查找表进行高效率的查找。这里讲到了二叉排序树和B-树，以及在这些树表上进行查找和修改操作的方法。<br>6.二叉排序树(BST)又称二叉查找树，其定义是：二叉排序树要或者是空树或者满足如下性质的二叉树：<br>1)若它的左子树非空，则左子树上所有结点的值均小于根结点的值；<br>2)若它的右子树非空，则右子树上所有结点的值均大于根结点的值；<br>3)左、右子树本身又是一棵二叉排序树。</p>
<p>（1）二叉排序树实际上是满足BST性质的二叉树。<br>（2）二叉排序树的插入、建立的算法平均时间性能是O(nlgn),但其执行时间约为堆排序的2至3倍。二叉排序树的删除操作可分三种情况进行处理：<br>1)<em>P是叶子，则直接删除</em>P，即将<em>P的双亲</em>parent 中指向<em>P的指针域置空即可。<br>2)</em>P只有一个孩子<em>child,此时只需将</em>child和<em>p的双亲直接连接就可删去</em>p.<br>3)<em>p有两个孩子,则将操作转换成删除</em>p结点的中序后继，在删去它之前把这个结点的数据复制到原来要删的结点位置上就完成了删除。<br>（3）二叉排序树上的查找和二分查找类似，它的关键字比较次数不超过树的深度。在最好的情况下，二叉排序树在生成的过程中比较匀称，此时的叉排序树是平衡的二叉树(也就是树中任一结点的左右子树的高度大致相同)，它的高度约为1.44lgn，完全平衡的二叉树高度约为lgn.在最坏的情况下，输入的实例产生的二叉排序树的高度将达到O(n),这种情况应当避免。</p>
<p>7.关于B-树(多路平衡查找树)。它适合在磁盘等直接存取设备上组织动态的查找表，是一种外查找算法。<br>B树的阶是指B-树的度数，B-树的结点具有k个孩子时，该结点必有k-1(k&gt;=2)个关键字。<br>实际上B-树是二叉排序树的推广，它就是一棵m叉树，且满足四个性质，这些性质与二叉排序树有相似之处，请仔细理解之。</p>
<p>8.上面的几种查找方法均是建立在比较关键字的基础上，因此它们的平均和最坏情况下所需的比较次数的下界是lgn+O(1).</p>
<p>9.散列技术：可以无需任何比较就找到待查关键字，其查找的期望时间为O(1).<br>散列表的概念：就是将所有可能出现的关键字的集合U(全集)映射到一个表T[0..m-1]的下标集上，这个表就是散列表。<br>10.而关键字与这个表地址之间以什么样的关系发生联系呢，这就要通过一个函数来建立，这个函数是以U中的关键字为自变量，以相应结点的存储地址为函数值，它就称为散列函数。将结点按其关键字的散列地址存储到散列表的过程称为散列。<br>11.根据某种散列函数，一个关键字的散列函数值是唯一的，但是有可能两个或多个不同关键字的函数值是相同的，这时就会把几个结点存储到同一个表位置上，这时就造成冲突(或碰撞)现象，这两个关键字称为该散列函数的同义词。<br>要完全(不是”安全”)避免冲突需满足两个条件，一是关键字集合U不大于散列表长m，另一个是选择合适的散列函数,如果用h(ki)=0)这样的函数的话，看看有什么结果。</p>
<p>12.通常情况下U总是大大于m的，因此不可能完全避免冲突。冲突的频繁程度还与表的填满程度相关。装填因子α表示表中填入的结点数与表长的比值，通常取α≤1，因为α越大，表越满，冲突的机会也越大。<br>13.散列函数的选择有两条标准：简单和均匀。看看h(ki)=0这样的函数，简单是简单，但绝不均匀。</p>
<p>14.下面是常见的几种散列函数构的造方法：<br>（1）平方取中法<br>（2）除余法：它是用表长m来除关键字，取余数作为散列地址。若选除数m是关键字的基数的幂次，就会使得高位不同而低位相同的关键字互为同义词。因此最好选取素数为除数.<br>（3）相乘取整法：有两个步骤，先用关键字key乘上某个常数A(0)<br>（4）随机数法，此法以关键字为自变量，通过一随机函数得到的值作为散列地址。</p>
<p>15.处理冲突的方法：当不可避免发生冲突时，就必须对冲突加以解决，使发生冲突的同义词能存储到表中。</p>
<p>16.通常有两类方法处理冲突：开放定址法和拉链法。前者是将所有结点均存放在散列T[0..m-1]中，后者是将互为同义词的结点链成一个单链表，而将此链表的头指针放在散列表中。</p>
<p>17.开放定址法的一般形式为：hi=(h(key)+di)%m 1≤i≤m-1<br>18.开放定址法要求散列表的装填因子α≤1。开放定址法又有线性探查法、二次探查法和双重散列法之分。<br>（1）由于线性探查法在构造散列表时，遇到冲突(有同义词)的时候会按探查序列向后面的空地址插入，从而使原来应插入到此位置的结点又与它发生冲突，当一连串的位置均已有结点时，本应插入到这些位置的结点又只能将其插入到更后面的同一个空结点上，这种散列地址不同的结点争夺同一个后继散列地址的现象就是聚集或堆积。(注意，同义词发生冲突不是堆积)<br>为了减小堆积现象的发生，可以用二次探查法和双重散列法进行探查。<br>（2）拉链法解决冲突的做法是，将所有关键字为同义词的结点链接在同一个单链表中。</p>
<p>19.与开放定址法相比，拉链法有如下几个优点：<br>(1)拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；(简单无堆积)<br>(2)由于拉链法中各链表上的结点空间是动态申请的，故它更适于造表前无法确定表长的情况；(动态申表长)<br>(3)开放定址法为减少冲突要求装填因子α较小，当结点规模较大时会浪费很多空间，拉链法中α可以大于1，且结点较大时，其指针域可忽略不计，因此节省空间；(空间可节省)<br>(4)拉链法构造的散列表删除结点易实现，而开放定址法中则不能真正删除结点只能做删除标记。(删除易实现)<br>20.拉链法也有缺点：当结点规模较小时，用拉链法中的指针域也要占用额外空间，还是开放定址法省空间。</p>
<p>21.在散列表上的运算有查找、插入和删除,主要是查找。这三个操作的算法并不复杂，也容易理解。关于查找操作的时间性能，可看教材p202的表9.1。由表可见，散列表的平均查找长度不是结点个数n的函数，而是装填因子α的函数。α越小，冲突的概率越小，但空间的浪费将增加，当α大小合适时，散列表上的平均查找长度就是一个常数，时间性能是O(1).</p>
<p>第 十 章   文 件</p>
<ol>
<li>对数据结构来说，文件是性质相同的记录的集合。</li>
<li></li>
<li>记录是文件中存取的基本单位，数据项是文件可使用的最小单位，数据项有时称字段或者属性。主关键字项(唯一标识一个记录的字段)、次关键字项、主关键字、次关键字。单关键字文件、多关键字文件等。</li>
</ol>
<p>3.文件的逻辑结构是一种线性结构。</p>
<p>4.文件上的操作主要有两类：检索和维护。并有实时和批量处理两种处理方式。</p>
<p>5.文件的存储结构是指文件在外存上的组织方式，基本的组织方式有：顺序组织、索引组织、散列组织和链组织。文件组织的各种方式往往是这四种基本方式的结合。</p>
<p>6.常用的文件组织方式：顺序文件、索引文件、散列文件和多关键字文件。</p>
<p>7.评价一个文件组织的效率，是执行文件操作所花费的时间和文件组织所需的存储空间。通常文件组织的主要目的，是为了能高效、方便地对文件进行操作，而检索功能的多寡和速度的快慢，是衡量文件操作质量的重要标志。</p>
<p>8.顺序文件：是指按记录进入文件的先后顺序存放、其逻辑顺序和物理顺序一致的文件。<br>1）一切存储在顺序存储器(如磁带)上的文件都只能顺序文件。这种顺序文件只能按顺序查找法存取(注意，没有折半法了)<br>2）存储在直接存取存储器(如磁盘)上的顺序文件可以顺序查找法存取，也可以用分块查找法或二分查找法存取。<br>3）顺序文件多用于磁带。</p>
<p>9.索引文件：组织方式：通常是在文件本身(主文件)之外，另外建立一张表，它指明逻辑记录和物理记录之间一一对应的关系，这张表就叫做索引表，它和主文件一起构成索引文件。<br>1）索引非顺序文件中的索引表为稠密索引。索引顺序文件中的索引表为稀疏索引。<br>2）若记录很大使得索引表也很大时，可对索引表再建立索引，称为查找表。通常可达四级索引。</p>
<p>10.索引顺序文件：是最常用的文件组织：因为索引顺序文件的主文件也是有序的，所以它既适合于随机存取也适合于顺序存取。另一方面，索引非顺序文件的索引是稠密索引，而索引顺序文件的稀疏索引，占用空间较少，因此索引顺序文件是最常用的一种文件组织。<br>1）索引顺序文件常用的有两种：ISAM文件和VSAM文件</p>
<p>11.散列文件：是利用散列存储方式组织的文件，亦称为直接存取文件。<br>1）它类似于散列表，即根据文件中关键字的特点，设计一个散列函数和处理冲突的方法，将记录散列到存储设备上。与散列表不同的是，对于文件来说，记录通常是成组存放的，若干个记录组成一个存储单位，称为桶。对散列而言，处理冲突的方法主要采用拉链法。<br>2）散列文件的优点是:文件随机存放，记录不需要排序；插入删除方便；存取速度快；不需要索引区，节省存储空间。缺点是：不能进行顺序存取，只能按关键字随机存取，且询问方式限地简单询问，需要重新组织文件。</p>
<p>12.对被查询的次关键字也建立相应的索引，则这种包含有多个次关键字索引的文件称为多关键字文件。<br>1）两种多关键字文件的组织方法：多重表文件和倒排表。<br>2）一般的文件组织中，是先找记录，然后再找到该记录所含的各次关键字；而倒排文件是先给定次关键字，然后查找含有该次关键字的各个记录，因此称为倒排。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章，未经许可，任何单位及个人不得做营利性使用！如有侵权请联系作者。
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2016/06/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            linux-常用命令大全
          
        </div>
      </a>
    
    
      <a href="/2016/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">数据结构-算法分析</div>
      </a>
    
  </nav>

  
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2020
        <i class="ri-heart-fill heart_icon"></i> 翟天野
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.svg" alt="Tianye Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  
  if(document.getElementsByClassName("tocbot").length !== 0){
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      scrollContainer: 'main',
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto'
    });
  }
</script>

<script src="/comm/jquery.modal.min.js"></script>
<link rel="stylesheet" href="/comm/jquery.modal.min.css">
<script src="/comm/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="/comm/photoswipe_dist/photoswipe.css">
<link rel="stylesheet" href="/comm/photoswipe_dist/default-skin/default-skin.css">
<script src="/comm/photoswipe_dist/photoswipe.min.js"></script>
<script src="/comm/photoswipe_dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="/comm/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>